## 第一章.计算机组成与体系结构

### 1.数据的表示

#### 1.进制转换 

1.1其他进制转十进制（注意小数点前第一位是0次方）

 ![image-20250309140343964](assets/image-20250309140343964.png)

1.2其他进制转十进制

1.2.1除基取余法，基就是比如二进制，基就是2

![image-20250309140353816](assets/image-20250309140353816.png)

1.2..2减法（记住2的前十次方就行，在算ip地址的时候有用）

![image-20250309140406945](assets/image-20250309140406945.png)

1.2.3 二进制转八进制和十六进制（以及十六进制和八进制反转二进制）

注意0x000F和000FH等价,都代表十六进制数000(15)

注意点就是 看下面 10001110转换为八进制就是216，一个八进制代表三位2进制，一个十六进制代表四位二进制

![image-20250309140415009](assets/image-20250309140415009.png)

#### 2.原反补码

**计算机中的计算都是运用补码计算的，没有负数，所以符号位用1代替负号**

**移码就是补码的符号位取反，其他位不变，记住就行**

如下图可以看出 用数值1的原码加上数值-1的原码 为 00000001 加上 10000001 值为10000010 换算一下为-2 不准确

用反码计算 00000001加上11111110 值为11111111 换算为十进制也不对

但是用数值1和数值-1的补码计算 00000001 加上11111111 为100000000 换，**但是计算机固定取后八位字长**，前面那位1被省略了，所以值为00000000，换算十进制为+0 是准确的 所以可以看出用补码计算最准确

![image-20250309140423568](assets/image-20250309140423568.png)

2.2原反补移的取值范围和可取个数

2.2.1原码的取值范围（反码和原码是一样的）

举例当n=3，也就是有三位的时候，分别有000,001,010,011,第一位算作符号位时，代表-0，-1，-2，-3也就是-0~-3；以及100，101，110，111，第一位也是第一位做符号位，代表+0,+1,+2,+3,也就是+0~+3,然后算能取值的范围就是去除符号位的绝对值也就是11最大，不好算就用二进制的11+1也就是二进制的100，也就是2的2次方，然后减去刚刚加上的1，也就是2的2次方-1，然后带上符号位，取值范围就是负2的2次方-1到正2的2次方-1，由于n是3，所以取值范围就如下;

而数码的个数如n=3时为2x2x2=8，**而+0和-0其实是一样的-0是没有意义的**(这里按照这么理解就行)，所以减去，个数为8-1=7个

2.2.2补码和移码取值范围和可取个数(**补码这里常考，不算很懂**)

还是以n=3举例，移码和补码通过**人为规定**将负0（因为n=3所以是100）也就是100扩大最小值取值范围变为负2的二次方(**这里是认为规定最前面那位1即做符号位又做数值位,本质也就是1100，化为十进制为-4**)，所以取值范围的最小值不需要像原码和反码一样-1，为-2的n次方，，而正数最大值还是3没变所以还是二的n次方-1,最大值到最小值范围即是负2的n次方~正2的n次方-1，而数码个数由于多了-0，所以不需要减去一，为2的n次方

总结:**人为规定的补码和移码中-0的符号位也算数值位，比如100，实际就是负2的2次方，也就是-0的补码当作负数最大值x`十进制的-128；在原码和反码中不要-0**

2.2.3定点小数，也就是没有整数位的原反补移的取值范围

假如n=3，原码和补码，那么定点小数第一位为符号位，然后紧跟一个小数点，然后跟后两位，也就是最大为0.11,我们还是可以加上0.01，结果为1.00，也就是1，然后0.01为2的-2次方，用1-2的-2次方的正负值就是定点小数的取值区间**；补码和移码还是由于有一个-0的存在，-0也就是1.00，由人为规定最前方这个1既作为符号位也作为数值位，所以-0可以转化为-1.00也就是-1，因为哪怕是没有认为规定的最小值0.11转换为十进制也是负的1-2的负n-1次方，还是比-1要大，**数码的个数和定点整数一致

![image-20250309140436054](assets/image-20250309140436054.png)

例题1

![image-20250309140457027](assets/image-20250309140457027.png)

例题2

注意 这里的2X是2*X，可以理解成数学里面 方程里面的2x 就是2乘X，在计算机中H是十六进制的标识，B是2进制的表示，没有特殊标识，就是十进制。90H转换为二进制就是10010000 补码-1就是反码，为10001111，在转换为原码，为11110000，第一位是符号位，所以可以理解为-01110000，换算成二进制为-116，2乘X等于-116,X等于-56

![image-20250309140511607](assets/image-20250309140511607.png)

#### 3.浮点数的表示

![image-20250309140518506](assets/image-20250309140518506.png)

浮点计算例题1

解题思路，首先按照下图写出十六位的数，顺序是阶符-阶码-数符-尾数，求取值范围，所以就是用正负最大绝对值即可算出

首先算出阶码和阶符的最大最小值，阶符为0，阶码为111111为最大，组合起来为0111111，加1为2的六次方也就是64，再减去加的1为63，我们需要记住一点，阶码最小值是认为规定的-0，也就是阶符为1，阶码为000000，组合为1000000，符号位也作为数值位，所以最小值为-2的六次方，为-64，所以阶码的范围为-64~63；然后看数符加尾数，浮点数可以看成定点小数，所以组合起来最大值为0.11111111,加上0.00000001等于1，0.00000001为2的负8次方，所以尾数加数符最大值为1-2的负八次方，最小值一样的不需要思考，由于用补码表示，所以最小值就是1.00000000，认为规定符号位也作为数值位置，所以最小值为-1；结合起来 该浮点数可表达范围是-1乘2的负64次方~1-2的负八次方乘2的六十三次方,通过最大值阶码为63排除A和C，然后B和D的最大值相同，比较最小值，最小值那个更小，表示的范围更大，可以看出B举例零的左侧更小，范围更大，且在刚刚计算的这个浮点数表示范围内，选B,(**注意一下，-1x2^63才是整体最小值,而不是-1x2^-64**)



![image-20250309140524556](assets/image-20250309140524556.png)

#### 4.逻辑运算

关系运算符

![image-20250309140530940](assets/image-20250309140530940.png)

数据的表示 逻辑运算（知道就行）

![image-20250309140538316](assets/image-20250309140538316.png)

逻辑运算符（大概知道就行）

![image-20250309140552384](assets/image-20250309140552384.png)

看一下下面例子运算即可(可以看看，帮忙理解，计算机里面没有true，false，只有0代表false，1代表true)

![image-20250309140559104](assets/image-20250309140559104.png)

**真题训练**

a的低四位假设为0000，和0x000F比较实际上就是和F比较，F就是1111，选项a，0000和1111逻辑与运算结果为0000，运算结果为0，所以选a，；看b选择，举个反例就行 加入a后四位是0111和F也就是1111逻辑或运算，结果是1111，也是F，所以错了，其他选项一样举反例

![image-20250309140605546](assets/image-20250309140605546.png)

### 2.校验码（常考）

![image-20250309140612365](assets/image-20250309140612365.png)

#### 1.奇偶校验（0个1也是偶数个1）

**说人话就是信息位加校验位的1的总数，为奇数如果是奇校验就校验成功**

![image-20250309140619240](assets/image-20250309140619240.png)

举例  如果有一个二进制1代表男，那么信息位就是1，如果是奇校验我们可以在信息位后面加上一个0，不能加1，加了1不就直接成偶数个1了，所以结果为10，当计算机检查到数据为00或者11的时候，就能检测到这个地方有误；

偶校验 ，如果信息位是1，我们加上校验位1，不能加0和上面同理，组成11，那么当我们收到数据为01，或者10的时候会报错，因为是奇数个1，所以可以检测到错误，但是当收到的数据是00呢检测不到错误，因为0个1也是偶数个1，所以奇偶校验有局限性。

例题

![image-20250309140624556](assets/image-20250309140624556.png)

A选项，按照我的理解，所有奇数位置出错，举个例子  真正的数据是101，前三位是信息位，第四位是校验位可以是1011，如果获取到的错误数据是0001，奇数为都错了，但是还是符合奇校验，所以错误；

B选项，101为数据，所以正确的偶奇验是1011，但是当我的数据是1110的时候，一样是所有偶数出错了，但是校验不出错误所在；

c选项是对的，奇数个数据位出错，说明符号位是对的，数据为101，正确奇校验是1011，当信息位也就是前三位有一个或者三个错误时候，0011，1001，0101可以看出错了；

D选项，偶数个数据位出错是看不出来的，可以理解为负负得正，原数据为101，正确奇校验为1011，就举个反例，0111，第一位和第三位数据位都出错了，那么刚好如果原本是01变成了10，还是奇数个1，如果原本是00变为11还是偶数个1，这样根本无法判断出哪一位错了

#### 2.循环校验码CRC(可检错，不可纠错)

![image-20250309140631024](assets/image-20250309140631024.png)

#### 3.海明码（重点，也叫汉明码）

**公式2的r次方>=m+r+1**,r代表海明码的个数，m代表所有传递的信息码的个数，要满足黑板列出的公式，例如我们要传的信息码值个数是16，海明码r=4时，不符合，所以r=5最符合，2的n次方就是海明码在数据中存放的每一个位置，此处r=5所以位置在2的0次方，2的一次方一直到2的五次方五个位置

三种校验码总结

![image-20250309140636201](assets/image-20250309140636201.png)

例题

![image-20250309140642042](assets/image-20250309140642042.png)

看第二题D5在题中位置是10，海明码必须在2的n次方位置上，10等于8+2，第八位是p4，第二位是p2，所以在P4P2等于2的上面，也可以换成二进制为1010,快速定位到海明码位置

###  3.cpu组成

![image-20250309140649031](assets/image-20250309140649031.png)

![image-20250309140654530](assets/image-20250309140654530.png)

### 4.寻址方式

![image-20250309140703908](assets/image-20250309140703908.png)

### 5.CISC（C代表complex：复杂）和RISC（R代表reduce：精简）

**还算常考，需要通过描述知道是那种指令**

![image-20250309140723428](assets/image-20250309140723428.png)

![image-20250309140729469](assets/image-20250309140729469.png)

### 6.流水线（重点）

**（上午考一到两分，下面图示的1是一条流水线，2是一条，不是1到2到3是一条，别搞错了）**

![image-20250309140735898](assets/image-20250309140735898.png)

例题

理论公式（一条指令执行时间）+（执行指令条数-1）x流水线周期；

当理论公式不在正确选项里就用实际公式计算，流水线划分段数x流水线周期+（执行指令条数-1）x流水线周期，**流水线周期是一段指令中执行最长的那个时间**

![image-20250309140741687](assets/image-20250309140741687.png)

使用串行方式就是顺序执行，全部执行完（3+2+4）t*10=90t；流水线周期就是一条指令中取指，分析，执行中用时最长的时间（这里的三段只是举例，别的流水线可能有四段，五段），此处是4t；十条指令执行完理论公式（3+2+4）+（10-1）*t*4=45t；实践公式：k为3，因为分三段，然后算出来是48t

公式原理

![image-20250309140747588](assets/image-20250309140747588.png)

理论公式要记住，第一条指令的第一步执行完才能开始第二条指令的第一步，**第一条指令的任何一步都要在第二条指令之前，看上图的第一条指令的第三步没执行完，第二条指令的第二步执行完了，那么第二条指令的第三步要等第一条指令的第三步执行完才能开始**

实践公式本质就是每一个步骤都取流水线周期，也就是最长的步骤



![image-20250309140754203](assets/image-20250309140754203.png)

吞吐率=10/45t

最大吞吐率记公式就行，t就是流水线周期，所以这里等于1/4t

### 7.存储系统（一般考1-2分）

#### 1.层次化存储结构

![image-20250309140800976](assets/image-20250309140800976.png)

层次化存储结构-分类

![image-20250309140812068](assets/image-20250309140812068.png)

#### 2.Cache

概念

![image-20250309140820431](assets/image-20250309140820431.png)

![image-20250309140827231](assets/image-20250309140827231.png)

此处的例子是 如果访问一百次数据，90%cache访问命中率，那么按照上述公式，cache的周期为1ms，访问主存储器周期是100ms，那么

（90x1ms+10x100ms）/100就是平均访问周期=10.9ms 比光用主存储器快很多，考的不多，主要这个计算思路

cache-映像（三种映像记住下面总结即可）

![image-20250309140838853](assets/image-20250309140838853.png)

下面的原理了解即可，什么叫冲突，当cache的第0页有数据了，主存其他区的第0页放进去就是冲突，下面的例子就是如果cache的0-14也都有数据，那么出现冲突的概率就是2048-15-128  不冲突就是128    2048就是主存的总页数，15就是主存已经放进去的页数，不冲突就是cache的第十五页没有放数据，在主存中有128个第15页可以放进去

![image-20250309140845850](assets/image-20250309140845850.png)

全相联映像就是主存的每一页都可以放在cache的任意页

![image-20250309140852250](assets/image-20250309140852250.png)

组相联映像

![image-20250309140901093](assets/image-20250309140901093.png)

映像总结

![image-20250309140909005](assets/image-20250309140909005.png)

#### 3.主存-编址与计算

![image-20250309140914760](assets/image-20250309140914760.png)

![image-20250306211712751](assets/image-20250306211712751.png)

例题讲解

![image-20250309140043772](assets/image-20250309140043772.png)



1字节就是1b=8bit（比特），10000H到CFFFFH的内存的存储单元等于CFFFFH-10000H+1=30000H=3X16的四次方x8bit，换算为kB单位，（3X16的四次方x8bit）/8bit/2的十次方=3x2的六次方=192kb，至少需要3片，就是192kb/（64kx8bit），b=8bit，所以结果为3

8.输入输出技术（重点程序中断方式）

 数据传输控制方式

![image-20250309134835495](assets/image-20250309134835495.png)

![image-20250309142800823](assets/image-20250309142800823.png)

### 9.总线（考的不多）

![image-20250309143344559](assets/image-20250309143344559.png)

### 10.可靠性（考的话就是1-2分）

![image-20250309144837913](assets/image-20250309144837913.png)

串联系统与并联系统（是可靠性里面的内容）

R1,R2,R3这些就是可靠率，是一个百分比，不可靠率就是1-可靠率

所以下面串联的可靠率=R1XR2XR3....

并联可靠率就是1-所有不可考虑=1-（1-R1)X(1-R2)X(1-R3)

![image-20250309171021635](assets/image-20250309171021635.png)

N模混合系统（混合串联和并联）

![image-20250309171535000](assets/image-20250309171535000.png)

例题（这个选项a曾经反复考到过，没有可靠来源，死记硬背就行）

![image-20250309171810555](assets/image-20250309171810555.png)

这题选c

![image-20250309172024864](assets/image-20250309172024864.png)

### 11.性能指标（不常考，考到就是1-3分）

![image-20250309183108560](assets/image-20250309183108560.png)

例题

**这里知道的是ipc，每时钟周期运行执行条数其实就是执行时间，计算百万条指令每秒需要在cpi也就是执行时间上加一个m的单位，因为cpi是一条指令的平均执行周期，百万条指令当然需要加百万也就是m这个单位**

![image-20250309182622058](assets/image-20250309182622058.png)

### 12.章节总结和分值分布

![image-20250309183814487](assets/image-20250309183814487.png)

平均每次考试75分中考6分

![image-20250309183837436](assets/image-20250309183837436.png)

## 第二章.操作系统

主要都是概念

### pv操作（多写几个例题理解，必考）

![image-20250310215613993](assets/image-20250310215613993.png)

互斥模型

信号量就是打印机数量，因为打印机同时只能一个进程使用

![image-20250310215721217](assets/image-20250310215721217.png)

#### 进程管理-pv操作与同步模型

参考系不同，当一个市场只能容纳一个产品所以初始值为1，，当生产一个产品，送到市场，市场满了，所以是p操作-1 此时缓冲区为0不能再生产产品，然后消费者从市场拿走那一个产品，v操作+1，缓冲区由0+1变为1，市场又可以再放一个产品；

而当以产品为参考，初始值为0，产品送到市场就是v操作+1；当消费者取走产品就是p操作-1；

![image-20250310215302961](assets/image-20250310215302961.png)

互斥与同步模型结合

单缓冲区，所以s1=1，也就是市场存在一个缓冲区，s=1的意思是，当你执行的是先生产一个产品，然后消费产品这个进程；就不能再同时使用送产品到缓冲区，然后从缓冲区取产品这个进程了，这个s=1我感觉就是m，但是不能确定

![image-20250310220106877](assets/image-20250310220106877.png)

例题

由题可以看出temp其实就是缓冲区，当用户找到单元Tj买票时，如果另外一个用户也来买，是不是就有冲突了，所以这是典型的互斥模型，所以a地方应该是p（s）操作，当temp大于等于x，也就是大于用户购票数量时让Tj等于原来Tj-用户购票数，也就是剩余票数；然后我们要释放内存，V（s），这样就可以让下一个用户再来购票；当temp小于x的时候也是一样的，需要V（s），由此可以看出 s信号量取值应该为1，因为这个值本质就是互斥信号量，为了控制这个当前终端只有一个人在进行购票操作

![image-20250310222439206](assets/image-20250310222439206.png)

![image-20250310222423266](assets/image-20250310222423266.png)

#### 前驱图和pv操作图结合考察

**注意啊，p和v括号里面的操作都是针对于键线，而不是进程**

上面的图看的懂，后继进程需要检查前驱操作是否完成，所以就是p操作，前驱需要通知后继何时开始运转，所以是v操作，信号量针对的不是你有多少个进程，而是针对的你有多少条键线，四条健线所以四个信号量，键线的箭头处是p操作，键线的末尾是v操作。

后面听懂的 ，下面半张图的意思是比如Pa执行就是A线程执行，在A线程执行前没有前驱，在A线程执行完之后有个后继，所以当A线程执行完毕后，V(Sa),其他两个同理，再看D进程那个图，首先D进程执行前存在三个前驱，所以需要分别三个P进行完后，D线程才会执行，当D线程执行完后，前驱图中D线程还存在后继，所以要进行V(Sd)操作释放内存，然后到E线程，存在一个前驱，所以要P(Sd)，没有后继

![image-20250311205527637](assets/image-20250311205527637.png)

例题

![image-20250311214107491](assets/image-20250311214107491.png)

![image-20250311214126211](assets/image-20250311214126211.png)

结果是C，B,B,首先知道s1-s5是那五条键线，，然后看a空，p1执行后，a就是v操作，看看四个选项中存在v操作的是A和C，且p1存在两个v操作，所以结果为C选项，且我们知道了p2的前驱是p(s1)，所以通过选项我们能知道p1到p3的键线是s2；通过p4是的前驱是p(s3)，所以我们知道p2和p4之间的信号量是s3，所以b空是v(s3)

然后看c空，p3的前驱是p(s2)，p3执行后的d空可以看出是有一个后继，所以是一个v操作，然后排除后由选项可以知道p3到p4之间是s4，所以是d空是v(s4)；

e空和f空一样

#### 进程死锁资源数计算

![image-20250312194545272](assets/image-20250312194545272.png)

由下图可以看出，当资源数小于4个一定死锁，当资源数等于4个可能死锁，可能不死锁，当资源数等于3x5=15的时候也是可能死锁，可能不死锁，一旦资源数大于15，等于16时一定有一个进程可以完成运行，并释放资源给其他进程；**下面公式中w是每个进程需要资源数；m是进程数；n就是资源数，达成这个条件n>=16,进程一定不会死锁，注意求的是死锁还是不死锁**

![image-20250312195507019](assets/image-20250312195507019.png)

根据下

![image-20250312195854547](assets/image-20250312195854547.png)

**进程资源图**

先处理分配，然后处理申请

![image-20250312204809126](assets/image-20250312204809126.png)

例题

首先分配，两个r1分别分配给p1和p3；三个r2分配给p2一个，p3一个还剩一个r2；全部分配看完再看请求，p1向r2申请一个资源，然后r2没有可分配资源了，再然后p2向r1申请资源，r1没有资源，所以p2是阻塞节点，p3同理，**这里可以看出考虑是否为阻塞节点是不考虑资源释放的**，然后是否可化简的意思是，p1执行完后释放一个r1，由于p1释放了一个r1，所以p2可执行，然后释放一个r2，然后p3可执行，全部可执行的都可以化简掉，最后啥都不剩，所以当前进程资源图可化简，非死锁，死锁就是资源图最后无法全部化简。

![image-20250312205331130](assets/image-20250312205331130.png)

断页式存储

页式存储（常考）

物理地址就是用页表里面页码对应的页帧号替换逻辑地址中的页号

下图中的逻辑地址是10110011011110 后十二位是页内地址，前两位是页号，为2，2代表的页帧号是6，所以物理地址是110110011011110

**总容量等于存储个数x偏址内容（默认题干没有声明情况下，偏址内容是1B，也就是1字节）**

**下面这个4kb 是2的12次方b，4k明明是十三位啊，4kb=4096，这是因为4096代表的地址为0-4095这4096个地址，4095就是十二位的1，没有到第十三位，所以这一页大小最大为十二个1 也就是0到二进制的十二个1**



![image-20250312213435615](assets/image-20250312213435615.png)

断页存储淘汰的是在内存中的，淘汰依据优先考虑访问位为0，也就是最近没有被访问过的（就近时间原理）；然后考虑修改位为0

![image-20250312215103085](assets/image-20250312215103085.png)![image-20250312215104722](assets/image-20250312215104722.png)

![image-20250312215552458](assets/image-20250312215552458.png)

例题

物理页大小是1kb，代表的是0-1023也就是0到2的10十次方-1，是十位，，1023是1111111111，所以是逻辑地址的后十位，逻辑地址1024等于2的十次方是十三位 1000000000000 ，这里一定注意，所以 后十二位为页内地址，第一位1是逻辑页，对应的物理页是3，

然后第二空这个假设就是结果，就是很奇妙的送分给你，具体如何共享物理页我们不需要知道

![image-20250312220822477](assets/image-20250312220822477.png)

段式存储（考的不多）

合法段的判断根据段长，如果断肠是30k，你的偏移量是（0,25k）那么偏移量是合法的，如果偏移量是(0,35K)大于了30k的段长，那就非法了，只有合法的逻辑地址可以转换为物理地址

基址就是内存存储的起始地址，逻辑地址是：（段号，段内偏移量）

![image-20250312221805755](assets/image-20250312221805755.png)

例题

可以看出 前面是段号，段号对应的偏移量，只有B选项全部符合

![image-20250312222309099](assets/image-20250312222309099.png)

#### 磁盘管理（较常考）

磁道号就是柱面号，磁盘的计算只用看磁道或者柱面号

![image-20250313202000116](assets/image-20250313202000116.png)

例题

![image-20250313201940962](assets/image-20250313201940962.png)

##### 先来先服务算法

根据访问顺序依次移动磁道

![image-20250313202808335](assets/image-20250313202808335.png)

##### 最短寻道时间优先算法

离90前后有58和160号磁道，由于58更近，所以就依次向外，最后到了18以后没有向外最近的磁道就向内找，找到最近是150，依次进行

![image-20250313202913806](assets/image-20250313202913806.png)

例题1

有难度，正常题目是没有这个图示的，这题其实考的是流水线，当数据读入缓冲区到缓冲区将数据送至用户区时，单缓冲区是只能等待的，只能等到这两步完成后才能开始下一次，但是工作区处理数据是可以同时进行的，就是可以在工作区处理数据时候开始下一次读入缓冲区操作，这其实就是一个分为两段的流水线，前面两部分的15us和5us是一部分，后面处理数据的1us是一部分；

双缓冲区的时候如下图示例可知，就是说当你第一次读入缓冲区，缓冲区送至用户区这一步可以同时并行处理了，也就是流水线被分成了三段，按照这三段流水线进行计算；

![image-20250313205923796](assets/image-20250313205923796.png)

![image-20250313205954327](assets/image-20250313205954327.png)

例题2

同一个柱面不用区分扇区或者磁头号

![image-20250313211102234](assets/image-20250313211102234.png)

例题3（很巧妙）

一个磁道11个物理块，旋转周期位33ms，所以处理一个块是33/11=3ms，先要知道，磁头需要将整个R0走完以后才能读取在缓冲区读取R0的数据，当花3ms走完R0开始读取数据，读取数据花费3ms，要知道这3ms柱头不会停止旋转，所以当R0处理完，实际柱头已经到了R2的起点，所以还要转30ms才能开始读取R1，所以读取R0的时间是3ms+3ms，而R1的时间是30ms+3ms+3ms，后面一直到R10同理，这样算出来最长时间6+36x10=366ms；而最优分布的意思就是，因为物理块的位置可以任意摆放，所以看第二张图右侧这个摆放位置，当R0读取完开始且处理完后，刚好到原先R2开始的位置放置R1，这样磁盘又会刚好读取R1，一直这么间隔放，刚好两圈可以读完真个磁盘，最少时间就是66ms

![image-20250313213044666](assets/image-20250313213044666.png)

![image-20250313213108849](assets/image-20250313213108849.png)

#### I/O管理软件（考一分）

知道这个分层就行

![image-20250314210118682](assets/image-20250314210118682.png)

#### 文件管理（考的较频繁）

##### 文件概念（考的很散）

![image-20250314210656774](assets/image-20250314210656774.png)

![image-20250314211017932](assets/image-20250314211017932.png)

系统将目录文件修改的结果写回磁盘时发生崩溃，对系统影响较大。

##### 树形目录结构（常考）

绝对路径是从盘符斜杠/开始的，好比寄快递，要从国家开始填，相对路径就是送外卖，不需要从国家开始，从你所在城市开始，你填你是什么小区就行，且不需要/，示例如下

![image-20250314211920884](assets/image-20250314211920884.png)

#### 索引文件

**考察形式：逻辑页号，使用索引方式，访问磁盘次数，访问磁盘次数（直接索引一次，一级两次，二级三次，以此类推）；最大文件长度**

一整个索引节点上其实就是多个地址项，每个地址项指向磁盘数据块，**下面可知一个地址项4B，一个磁盘索引块1KB，所以1KB/4B=256，也就是一个磁盘索引块可以装256个地址项，磁盘数据块大小也是1KB**由于地址项是由0开始，所以就是第0到第255块地址项，也就是一级索引块里面装有256个地址项，然后致谢地址项指向的就是真正的磁盘数据块的位置；二级间接索引就是比如下图的4里面的地址项指向的是一个装满256个地址项的磁盘索引块（可以叫2级索引块），然后这256个地址项的每一个地址项又分别指向装满了256个地址项的磁盘索引块（1级），然后这256个地址项才分别指向真正的存放磁盘数据块的地方，要注意 如图，这里所有真正的磁盘数据块根据索引是有顺序的排列的

![image-20250315121902317](assets/image-20250315121902317-1742120958986-1.png)

例题

![image-20250315133024695](assets/image-20250315133024695-1742120958986-2.png)

![image-20250315132951140](assets/image-20250315132951140-1742120958986-5.png)

#### 作业管理(了解即可)

#### 章节汇总

![image-20250315135612867](assets/image-20250315135612867-1742120958986-3.png)

#### 考试频率

![image-20250315135652631](assets/image-20250315135652631-1742120958986-4.png)

## 第三章.程序设计语言与语言处理程序基础

### 程序设计语言概述

#### 1.编译程序与解释程序

![image-20250315142538686](assets/image-20250315142538686-1742120958986-6.png)

#### 2.多种程序语言的特点(仅了解)

![image-20250315142840116](assets/image-20250315142840116-1742120958986-7.png)

#### 3.程序设计语言基本组成成分(常考)

![image-20250315143327651](assets/image-20250315143327651-1742120958987-8.png)

#### 4.函数调用方式(常考)

![image-20250315144152215](assets/image-20250315144152215-1742120958987-9.png)

传递方式的例子

![image-20250315145613535](assets/image-20250315145613535-1742120958987-10.png)

例题

![image-20250315151441700](assets/image-20250315151441700-1742120958987-11.png)

![image-20250315151414066](assets/image-20250315151414066-1742120958987-12.png)

### 编译程序基本原理

#### 1.编译过程概述

![image-20250315155245219](assets/image-20250315155245219-1742120958987-13.png)

##### 词法分析

![image-20250315154307038](assets/image-20250315154307038-1742120958987-14.png)

![image-20250315154620082](assets/image-20250315154620082-1742120958987-15.png)

##### 语法分析

![image-20250315154357709](assets/image-20250315154357709-1742120958987-16.png)

![image-20250315154632644](assets/image-20250315154632644-1742120958987-19.png)

##### 语义分析

语法指导翻译是一种静态语义分析

![image-20250315154725688](assets/image-20250315154725688-1742120958987-17.png)

![image-20250315155418976](assets/image-20250315155418976-1742120958987-18.png)

![image-20250315154641608](assets/image-20250315154641608-1742120958987-20.png)

#### 2.文法(很抽象，很多东西没听懂)

大多数程序设计语言的语法规则用**上下文无关文法**描述

##### 语法推导树(看这个例题就懂了)

语法推导树可能有多个，最终目的就是组合成一个我们想要的结果



![image-20250315165229817](assets/image-20250315165229817-1742120958994-21.png)

![image-20250315165157519](assets/image-20250315165157519-1742120958994-22.png)

例题2(要掌握)

难度有点大，主要用排除法做，考试不会考这么难的表达式

![image-20250315171307665](assets/image-20250315171307665-1742120958994-23.png)

![image-20250315171228005](assets/image-20250315171228005.png)

#### 3.正规式与正规集

![image-20250317200614989](assets/image-20250317200614989.png)

例子

![image-20250317200517568](assets/image-20250317200517568.png)

#### 4.有限自动机

反向的3，就是那木他，代表的是无需识别，就是他中间经过的过程当作空

![image-20250317203235154](assets/image-20250317203235154.png)

例题

![image-20250317203133165](assets/image-20250317203133165.png)

![image-20250317203446061](assets/image-20250317203446061.png)

#### 5.后缀表达式

优先级，注意计算顺序

![image-20250317205021444](assets/image-20250317205021444.png)

这里计算都是和栈有关，先进后出，后进先出

![image-20250317205414507](assets/image-20250317205414507.png)

![image-20250317205502241](assets/image-20250317205502241.png)

这个真题没看懂

![image-20250317204516366](assets/image-20250317204516366.png)

#### 6.总结及分值分布

![image-20250317205951929](assets/image-20250317205951929.png)

![image-20250317210005944](assets/image-20250317210005944.png)

## 第四章.数据库系统

### 1.数据库的基本概念

#### 1.数据库体系结构

![image-20250317212431391](assets/image-20250317212431391.png)

分布式数据库特点

![image-20250317212936369](assets/image-20250317212936369.png)

![image-20250317213146307](assets/image-20250317213146307.png)

例题

![image-20250317213731279](assets/image-20250317213731279.png)

![image-20250317213800596](assets/image-20250317213800596.png)

![image-20250317214755168](assets/image-20250317214755168.png)

2.三级模式的结构

![image-20250317215204629](assets/image-20250317215204629.png)

例题

![image-20250317215754551](assets/image-20250317215754551.png)

3.数据仓库（不常考）

**OLAP:联机分析，是数据仓库的特点，注重于分析，预测；OLTP：联机事务，是我们数据库的特点，侧重于数据增加删改查**

![image-20250317220454465](assets/image-20250317220454465.png)

### 2.数据库设计（暂时没看完，这是大题主要）

![image-20250319210907587](assets/image-20250319210907587.png)

### 4.3E-R图

概念设计阶段

![image-20250322125048072](assets/image-20250322125048072.png)



![image-20250322125144637](assets/image-20250322125144637.png)

![image-20250322125202993](assets/image-20250322125202993.png)

一个班级一般有一个班长，一个班长一般对应一个班级，所以是一对一；一个班级一般有多个学员，所以是一对多，多个学员在一个班级，所以是多对一；而课程和学员之间，因为存在多个课程和多个学员，互相会存在选择，所以互相都是多对多

![image-20250322125645556](assets/image-20250322125645556.png)

多个实体间的联系

![image-20250322130522797](assets/image-20250322130522797.png)

实体集内的二元联系

![image-20250322130801303](assets/image-20250322130801303.png)

实体的分类

![image-20250322131541128](assets/image-20250322131541128.png)

### 4.4逻辑结构设计

4.4.1关系模式的相关概念

**数据模型的三要素**：数据结构，数据操作，数据的约束条件

**候选键**：唯一标识元组，且无冗余，可以有一个，可以有多个，可以是单个属性或多个属性的集合；比如对于一个学生来说，学生的身份证号或者学号都可以代表一个学生，所以学号和身份证号都是学生的候选键，我们只能选一个进行标识，而对于成绩来说，用单个属性无法标识，需要用学号，课程号，才能代表一个学生某一科的成绩，所以这里是属性集合。

**主键**：就是从候选键中选出一个来作为这个属性的唯一标识

**外键:对于学生来说学号是主键，对于一门课程来说,假如课程号是主键，我们想要监理学生表和课程表的联系，就可以把课程表的主键课程号写入学生表中，所以对于学生表来说，课程号就是外键**

![image-20250322132521435](assets/image-20250322132521435.png)

#### 3.4.2E-R模型转关系模式(大题小题都会考)

![image-20250322122459946](assets/image-20250322122459946.png)

一对一联系转换

![image-20250322135534158](assets/image-20250322135534158.png)

一对多转换

![image-20250322143549014](assets/image-20250322143549014.png)

多对多转换**（主键是多端主键的集合）**

![image-20250322143953398](assets/image-20250322143953398.png)

### 4.5关系代数(考的多)

![image-20250322144839317](assets/image-20250322144839317.png)

**笛卡尔积就是s1和s2的每一行进行排列组合，且每一列可以按照顺序1，2，3，4，5，6标识；**

**投影就是取指定的那几列**

**选择就是取指定的行**

**s1.1=s2.1就是s1的Sno等于s2的Sno；1=2就是第一列等于第二列；1='1'就是第一列等于1**

![image-20250322150524991](assets/image-20250322150524991.png)



#### 自然连接

**自然选择除s1和s2相同的列，然后元组行是同列名的相同属性值哪一行，也等于先选择的笛卡尔积，再投影，不等于先投影的笛卡尔积再选择**

再sql语句中select代表的其实就是投影；from代表的就是笛卡尔积，where代表的就是选择

![image-20250322153426048](assets/image-20250322153426048.png)这个式子的计算是，先列出下面s1和s2的笛卡尔积，然后选择第一列和第四列相等的哪一行，然后投影1，2，3，5这四列，结构和自然选择相同

先筛选再进行笛卡尔积，性能更优，因为笛卡尔积是一个乘法，两侧的数据越少，算出来数据越少

![image-20250322153226390](assets/image-20250322153226390.png)

例题

![image-20250322160039288](assets/image-20250322160039288.png)

![image-20250322155823918](assets/image-20250322155823918.png)

例题2

![image-20250322160847866](assets/image-20250322160847866.png)

### 4.6规范化理论（必考）

#### 3.6.1规范化理论基本概念(上午常考)

函数依赖

![image-20250324201054835](assets/image-20250324201054835.png)

![image-20250322163546758](assets/image-20250322163546758.png)

公式需要大概记忆，会考选择题

自反律：如y=B集合，x=BC集合；U=ABC集合，BC可以决定B，所以x决定y成立；其他公式也按照这种集合推理



![image-20250322164250821](assets/image-20250322164250821.png)

候选键

做题思路

![image-20250323204405509](assets/image-20250323204405509.png)

例题

![image-20250323212024061](assets/image-20250323212024061.png)

主属性

**这一题三个属性都是主属性，因为通过(ST,CITY)可以推出ZIP,（ST,ZIP）也可以，先用ZIP推出CITY，然后CITY和ST联合推出ZIP，候选关键字是(ST,CITY)（ST,ZIP)这两个**

![image-20250323213643795](assets/image-20250323213643795.png)

例题

![image-20250323214324446](assets/image-20250323214324446.png)

![image-20250323214919653](assets/image-20250323214919653.png)

#### 3.6.2范式判断(必考，重点)

**范式判断核心首先找到候选键，其次找非主属性，然后改变关系模式，让他们符合范式**

![image-20250323215952967](assets/image-20250323215952967.png)

第一范式

![image-20250324195416827](assets/image-20250324195416827.png)

第二范式

![image-20250324200801837](assets/image-20250324200801837.png)

第三范式

![image-20250324201843535](assets/image-20250324201843535.png)

BC范式(只需掌握判断过程，拆分过程不需掌握)

![image-20250324203441420](assets/image-20250324203441420.png)

总结

![image-20250324203840746](assets/image-20250324203840746.png)

![image-20250324203947318](assets/image-20250324203947318.png)

例题

![image-20250324205401145](assets/image-20250324205401145.png)

#### 3.6.3模式分解  

**保持函数依赖分解**

**这里我刚开始理解错了R1(ABCE)中，不是A就代表A->BC这个函数依赖，而是R1中存在的属性就代表函数依赖在，因为R1(ABCE)中ABC都存在，所以A->BC,且BCE都存在所以依赖BC->E也存在，其他同理，不要理解错了**

![image-20250324210920511](assets/image-20250324210920511.png)

![image-20250324211402931](assets/image-20250324211402931.png)

![image-20250324214107333](assets/image-20250324214107333.png)

例题

![image-20250324213546057](assets/image-20250324213546057.png)

![image-20250324214427664](assets/image-20250324214427664.png)

**公式法(简单，但是超过两个关系模式不能用)**

![image-20250324214655871](assets/image-20250324214655871.png)

例题

![image-20250324223331743](assets/image-20250324223331743.png)

#### 3.7SQL语言

##### 3.7.1普通查询

![image-20250325204621852](assets/image-20250325204621852.png)

例题

![image-20250325204603239](assets/image-20250325204603239.png)

##### 3.7.2分组查询

GROUP一定和HAVING联用

COUNT是否 使用**DISTINCT**的作用是是否区分行，比如找出两个不同名字的人，但是一个表里 有一个人干了两件事，一个人干了一件事，如果按照事情找，就会找到三个，区分的话就能找到一个人干了两件事，就是两个人

![image-20250325205217548](assets/image-20250325205217548.png)

例题

![image-20250325211445978](assets/image-20250325211445978.png)

##### 3.7.3权限控制(考不多)

![image-20250325211823173](assets/image-20250325211823173.png)

#### 3.8并发控制

1.事务的特性

![image-20250325212608106](assets/image-20250325212608106.png)

2.并发控制（基本不考）

![image-20250325213603627](assets/image-20250325213603627.png)

3.封锁协议

![image-20250325213950752](assets/image-20250325213950752.png)

例题

![image-20250325214139250](assets/image-20250325214139250.png)

#### 3.9总结

![image-20250325214625799](assets/image-20250325214625799.png)

上午题考察

![image-20250325214711600](assets/image-20250325214711600.png)

## 第五章.面向对象

将大象装进冰箱

![image-20250330164858114](assets/image-20250330164858114.png)

### 面向对象的基本概念

面向对象 = 对象（Object）+ 分类（Classification）+ 继承（Inheritance）+通过消息的通信

#### 类

- 实体类：是应用领域中的核心类。实体类的对象表示现实世界中的真实的实体。
- 接口类（边界类）：的对象为用户提供一种与系统合作交互的方式，是系统内对象和系统外参与者的联系媒介
- 控制类：控制类的对象用来控制活动流，充当协调者

真题1

![image-20250330172729998](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330172729998.png)

真题2

![image-20250330172653977](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330172653977.png)

真题3

![image-20250330172901771](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330172901771.png)

真题4

![image-20250330173252685](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330173252685.png)

#### 对象和消息

![image-20250330183141760](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330183141760.png)





真题1

![image-20250330183332188](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330183332188.png)

真题2

![image-20250330183342789](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330183342789.png)

真题3

![image-20250330183353451](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330183353451.png)



真题4

![image-20250330183656225](C:\Users\wgt\AppData\Roaming\Typora\typora-user-images\image-20250330183656225.png)

#### 重载





## 第一个大题

问题4的总结

![image-20250330163932137](assets/image-20250330163932137.png)

## 第二个大题（如果有多个答案，采取相对最合理的）

### 实体

![image-20250329210525781](assets/image-20250329210525781.png)

![image-20250329210610647](assets/image-20250329210610647.png)

属性

![image-20250329211011445](assets/image-20250329211011445.png)

多个实体间的联系

![image-20250322130522797](assets/image-20250322130522797.png)

### 小题1的例题

如果有一边是1对1，另外一边没有明确的知道是不是多，那就默认互相是1对1

![image-20250329213417963](assets/image-20250329213417963.png)

这里我想错了

![image-20250329214355523](assets/image-20250329214355523.png)

![image-20250329214646287](assets/image-20250329214646287.png)

![image-20250329214937595](assets/image-20250329214937595.png)

问题2

关系模式

![image-20250329215124881](assets/image-20250329215124881.png)

关系模式转换

一对一（简单）

一对多

![image-20250329215311865](assets/image-20250329215311865.png)

### 多对多

![image-20250329215704025](assets/image-20250329215704025.png)

### 三个实体

共用一个关系，就采用多对多的，把所有实体的主键放到关系中，这三个主键的属性组是这个联系的主键

实体和子实体的转换

![image-20250329220344728](assets/image-20250329220344728.png)

例题1

**这个例题里面由很多技巧性思路可以学习**

![image-20250329222603835](assets/image-20250329222603835.png)

![image-20250329223357448](assets/image-20250329223357448.png)

![image-20250329223917711](assets/image-20250329223917711.png)

例题2

![image-20250329225724256](assets/image-20250329225724256.png)

![image-20250330160635460](assets/image-20250330160635460.png)

例题3

![image-20250330161608844](assets/image-20250330161608844.png)

![image-20250330161554235](assets/image-20250330161554235.png)

## 5.面向对象

### 5.1面向对象基本概念

![image-20250330184327927](assets/image-20250330184327927.png)

真题1

![image-20250330184359287](assets/image-20250330184359287.png)

真题2

![image-20250330184411278](assets/image-20250330184411278.png)

真题3

![image-20250330184418475](assets/image-20250330184418475.png)

真题4

![image-20250330184426149](assets/image-20250330184426149.png)

### 5.2对象和消息

![image-20250330184555777](assets/image-20250330184555777.png)

真题1

![image-20250330184607053](assets/image-20250330184607053.png)

真题2

![image-20250330184618597](assets/image-20250330184618597.png)

真题3

![image-20250330184627761](assets/image-20250330184627761.png)

真题4

![image-20250330184637947](assets/image-20250330184637947.png)

### 5.3方法重载

![image-20250330185408550](assets/image-20250330185408550.png)![image-20250330185505663](assets/image-20250330185505663.png)

真题1

![image-20250330190030354](assets/image-20250330190030354.png)

真题2

![image-20250330190046585](assets/image-20250330190046585.png)

### 5.4封装

![image-20250330190335477](assets/image-20250330190335477.png)

![image-20250330191825151](assets/image-20250330191825151.png)

上图声明的类的调用

![image-20250330192001605](assets/image-20250330192001605.png)

真题1

![image-20250330192206273](assets/image-20250330192206273.png)

真题2

![image-20250330192506892](assets/image-20250330192506892.png)

真题3

![image-20250330193104410](assets/image-20250330193104410.png)

真题4

![image-20250330193446705](assets/image-20250330193446705.png)

### 5.5继承

**继承是父类和子类之间共享属性和方法的机制。**

继承关系中的子类将全部拥有父类的全部属性和方法，但只能用非私有化的属性和方法

- 子类可以继承父类属性和方法
- 子类可以有自己特殊的属性和方法
- **子类可以重写父类属性和方法**  

java中的使用

![image-20250330195401426](assets/image-20250330195401426.png)

这是父类中的sleep方法

![image-20250330195504602](assets/image-20250330195504602.png)



![image-20250330195214681](assets/image-20250330195214681.png)

![image-20250330195123198](assets/image-20250330195123198.png)

真题1

![image-20250330195709705](assets/image-20250330195709705.png)

真题2

![image-20250330200151818](assets/image-20250330200151818.png)

真题3

![image-20250330200346796](assets/image-20250330200346796.png)

真题4

![image-20250330200659478](assets/image-20250330200659478.png)

### 5.6多态

在Java中，父类调用子类的相同名称的方法，编译看左边，运行看右边

![image-20250331205415084](assets/image-20250331205415084.png)

![image-20250331202632831](assets/image-20250331202632831.png)

![image-20250331202357435](assets/image-20250331202357435.png)

![image-20250331202427579](assets/image-20250331202427579.png)



![image-20250331202218763](assets/image-20250331202218763.png)

真题1

![image-20250331203018653](assets/image-20250331203018653.png)

真题2

![image-20250331203201915](assets/image-20250331203201915.png)

真题3

![image-20250331203230910](assets/image-20250331203230910.png)

真题4

![image-20250331203615302](assets/image-20250331203615302.png)

![image-20250331203711755](assets/image-20250331203711755.png)

真题6

![image-20250331204023468](assets/image-20250331204023468.png)

### 5.7静态绑定和动态绑定

编译是静态绑定，运行是动态绑定

![image-20250331205640225](assets/image-20250331205640225.png)

真题1

![image-20250331205817429](assets/image-20250331205817429.png)

真题2

![image-20250331205929255](assets/image-20250331205929255.png)

真题3

![image-20250331210008418](assets/image-20250331210008418.png)

### 5.8面向对象设计原则

记忆大致，都是考选择题

![image-20250331211014772](assets/image-20250331211014772.png)

![image-20250331212247157](assets/image-20250331212247157.png)

真题1

![image-20250331211232270](assets/image-20250331211232270.png)

真题2

![image-20250331211521957](assets/image-20250331211521957.png)

真题3

![image-20250331211656093](assets/image-20250331211656093.png)

真题4

![image-20250331211911173](assets/image-20250331211911173.png)

真题5

![image-20250331212039216](assets/image-20250331212039216.png)

### 5.9面向对象分析

记大概步骤

1. 认定对象
2. 组织对象
3. 描述对象间的相互作用
4. 确定对象的操作
5. 定义对象的内部信息。

![image-20250331212404227](assets/image-20250331212404227.png)

### 5.10面向对象设计

![image-20250331213031351](assets/image-20250331213031351.png)

### 5.11面向对象程序设计

![image-20250331215259968](assets/image-20250331215259968.png)

### 5.12.面向对象测试



面向对象测试是根据规范说明来验证系统设计的正确性。

1. 算法层：测试类中定义的每个方法，基本上相当于传统软件测试中的单元测试。
2. 类层：测试封装在同一个类中的所有方法与属性之间的相互作用。在面向对象软件中类是基本模块，因此可以认为这是面向对象测试中所特有的模块测试。
3. 模板层：测试一组协同工作的类之间的相互作用，大体上相当于传统软件测试中的集成测试，但是也有面向对象软件的特点（例如，对象之间通过发送消息相互作用）。
4. 系统层：把各个子系统组装成完整的面向对象软件系统，在组装过程中同时进行测试。

真题1

![image-20250331213945565](assets/image-20250331213945565.png)

真题2

![image-20250331214146265](assets/image-20250331214146265.png)

真题3

![image-20250331214411102](assets/image-20250331214411102.png)

真题4

![image-20250331214528091](assets/image-20250331214528091.png)

真题5

![image-20250331214744187](assets/image-20250331214744187.png)

真题6

![image-20250331214905434](assets/image-20250331214905434.png)

真题7 

![image-20250331214943490](assets/image-20250331214943490.png)

真题8

![image-20250331215107047](assets/image-20250331215107047.png)

真题9

![image-20250331215157848](assets/image-20250331215157848.png)



### 杂题

真题1

静态成员可以理解为全局变量，所以实例化对象共享这个变量的值，这个值随着实例对象的改变而改变

![image-20250401203832987](assets/image-20250401203832987.png)

![image-20250401204123376](assets/image-20250401204123376.png)

真题2

![image-20250401205320927](assets/image-20250401205320927.png)

![image-20250401210058653](assets/image-20250401210058653.png)

![image-20250401205619224](assets/image-20250401205619224.png)

真题3

![image-20250401210202737](assets/image-20250401210202737.png)

### 分值分布

![image-20250401210524552](assets/image-20250401210524552.png)

## 第六章.UML

### 6.1 UML概念

![image-20250401150609108](assets/image-20250401150609108.png)

### 6.2UML事物

![image-20250401152227419](assets/image-20250401152227419.png)

![image-20250401152243325](assets/image-20250401152243325.png)

真题1

![image-20250401152452238](assets/image-20250401152452238.png)

### 6.3关系

关联考的最多

![image-20250401154827427](assets/image-20250401154827427.png)

![image-20250401160054572](assets/image-20250401160054572.png)



![image-20250401165243944](assets/image-20250401165243944.png)

关联的无相边上方为重复度，下边为角色，中间可以是关联名

![image-20250401211612578](assets/image-20250401211612578.png)

**关联中的特殊情况聚集**

![image-20250401162107118](assets/image-20250401162107118.png)

![image-20250401162438191](assets/image-20250401162438191.png)

![image-20250401162718483](assets/image-20250401162718483.png)

真题1

![image-20250401163609582](assets/image-20250401163609582.png)

真题2

![image-20250401163859518](assets/image-20250401163859518.png)

真题3

![image-20250401164229704](assets/image-20250401164229704.png)

真题4

![image-20250401164342042](assets/image-20250401164342042.png)

真题5

![image-20250401164451987](assets/image-20250401164451987.png)

真题6

![image-20250401164747721](assets/image-20250401164747721.png)

真题7

![image-20250401165847147](assets/image-20250401165847147.png)

真题8

![image-20250401170305144](assets/image-20250401170305144.png)

### 6.4关联多重度

关联多重度：**一个类的实例能够对应另外一个类的多个实例，需要两边是多对多的关系**

![image-20250401181417852](assets/image-20250401181417852.png)

真题1

![image-20250401210915662](assets/image-20250401210915662.png)

真题2

![image-20250401211758527](assets/image-20250401211758527.png)

真题3

这题不要钻牛角尖，选相对最对的哪一个

![image-20250401212344022](assets/image-20250401212344022.png)

### UML图

### 1.类图(很多情况，多看看下面真题，真题五重点看)

![image-20250402113700517](assets/image-20250402113700517.png)

![image-20250402113733437](assets/image-20250402113733437.png)

![image-20250402133848098](assets/image-20250402133848098.png)

真题1

![image-20250402145514317](assets/image-20250402145514317.png)

真题2

![image-20250402153435134](assets/image-20250402153435134.png)

真题3

![image-20250402164147518](assets/image-20250402164147518.png)

真题4

- **组合关系的方向性是单向的**：整体控制部分，但部分不影响整体。

![image-20250402161055860](assets/image-20250402161055860.png)

**真题5**

![image-20250402163459137](assets/image-20250402163459137.png)

![image-20250402164319271](assets/image-20250402164319271.png)

### 2.对象图（小题考的少，大题没考过）

![image-20250402164521404](assets/image-20250402164521404.png)

真题1

![image-20250402165922008](assets/image-20250402165922008.png)

### 3.用例题(只考下午题)

![image-20250409211940415](../软考学习笔记/assets/image-20250409211940415.png)

3.1包含关系

包含关系描述的是一个用例需要某种功能，而该功能被另外一个用例定义，那么在用例的执行过程中，就可以调用已经定义好的用例。表示符号：`<<include>>`

![image-20250407194306325](assets/image-20250407194306325.png)

![image-20250407194317213](assets/image-20250407194317213.png)

![image-20250407194326519](assets/image-20250407194326519.png)

#### 3.2、扩展关系

用一个用例（可选）扩展另一个用例（基本例）的功能，将一些常规的动作放在一个基本用例中，将可选的或只在特定条件下才执行的动作放在它的扩展用例中。表示符号：`<<extend>>`

![image-20250407195444234](assets/image-20250407195444234.png)

![image-20250407195457590](assets/image-20250407195457590.png)

#### 3.3、泛化关系

![image-20250407200321667](../软考学习笔记/assets/image-20250407200321667.png)

![image-20250407203005937](assets/image-20250407203005937.png)

真题1

![image-20250407203954739](../软考学习笔记/assets/image-20250407203954739.png)

真题2

![image-20250409212437426](assets/image-20250409212437426.png)

### 4.交互图

![image-20250407205945274](assets/image-20250407205945274.png)

#### 4.1、序列图（顺序图）

**多个对象与一个用例的行为**

![image-20250407210007352](assets/image-20250407210007352.png)

![image-20250407210038284](assets/image-20250407210038284.png)

![image-20250407210631724](assets/image-20250407210631724.png)

真题1（可以看看）

![image-20250407211635302](assets/image-20250407211635302.png)

真题2

![image-20250407212013434](assets/image-20250407212013434.png)

真题3

![image-20250407212455026](assets/image-20250407212455026.png)

#### 4.2、通信图（协作图）

通信图展示了对象之间的消息流及其顺序

![image-20250407213514788](assets/image-20250407213514788.png)

![image-20250407213526957](assets/image-20250407213526957.png)

![image-20250407213537619](assets/image-20250407213537619.png)

真题1

![image-20250407214352665](assets/image-20250407214352665.png)

真题2

![image-20250407220138458](assets/image-20250407220138458.png)

### 5.状态图(很难，看真题)

![image-20250408193352586](assets/image-20250408193352586.png)

![image-20250408193406214](assets/image-20250408193406214.png)

![image-20250408193416513](assets/image-20250408193416513.png)

#### 5.1、状态

状态考的少，活动表考的多

![image-20250408193430483](assets/image-20250408193430483.png)

#### 5.2、事件

![image-20250408193443780](assets/image-20250408193443780.png)

![image-20250408195716743](assets/image-20250408195716743.png)

真题1

![image-20250408201910072](assets/image-20250408201910072.png)

真题2

![image-20250408203527702](assets/image-20250408203527702.png)

真题3

![image-20250408203940712](assets/image-20250408203940712.png)

真题4

![image-20250408205719499](assets/image-20250408205719499.png)

真题5(难)

![image-20250408205853630](assets/image-20250408205853630.png)

![image-20250408205823823](assets/image-20250408205823823.png)

真题6

![image-20250408210737707](assets/image-20250408210737707.png)

![image-20250408210749814](assets/image-20250408210749814.png)

### 6、活动图

和状态图区别：最明显，状态图是很小的圆角矩形，而活动图是特别大弧度，可以说是椭圆矩形

![image-20250408213536884](assets/image-20250408213536884.png)

![image-20250408214022517](assets/image-20250408214022517.png)

![image-20250408214144343](assets/image-20250408214144343.png)

真题1

![image-20250408214448522](assets/image-20250408214448522.png)

真题2

![image-20250408214724799](assets/image-20250408214724799.png)

真题3

![image-20250408214950593](assets/image-20250408214950593.png)

真题4

![image-20250408215042117](assets/image-20250408215042117.png)

### 7.构建图(组件图)

**记住调用供接口需要实现需接口**

![image-20250408215801992](assets/image-20250408215801992.png)

真题1

![image-20250408220358741](assets/image-20250408220358741.png)

真题2

![image-20250408220453829](assets/image-20250408220453829.png)

真题3

![image-20250408220615993](assets/image-20250408220615993.png)

### 8.部署图（上午题考的少，下午没考过，大概率不考）

部署图是立体矩形，这是特点

![image-20250409140124811](assets/image-20250409140124811.png)

真题1

![image-20250409140359415](assets/image-20250409140359415.png)

真题2

![image-20250409140422202](assets/image-20250409140422202.png)

真题3

![image-20250409140430682](assets/image-20250409140430682.png)

### 九、UML图总结

#### 9.1图分类

![image-20250409140730778](assets/image-20250409140730778.png)

#### 9.2图的特点

| 图     | 关系                                 |
| ------ | ------------------------------------ |
| 类图   | 一组对象、接口、协助和它们之间的关系 |
| 对象图 | 某一时刻一组对象之间的关系           |
| 用例图 | 一组用例与参与者之间的关系           |
| 序列图 | 多个对象与一个用例的行为             |
| 通信图 | 对象之间的消息流及顺序               |
| 状态图 |                                      |
| 活动图 | 一个活动到另一个活动的流程           |
| 构件图 | 一组构件之间的组织及依赖             |
| 部署图 | 软件与硬件的关系                     |

真题1

![image-20250409144353180](assets/image-20250409144353180.png)

真题2

![image-20250409144922969](assets/image-20250409144922969.png)

真题3

![image-20250409145505940](assets/image-20250409145505940.png)

10.杂题

真题1

![image-20250409151301762](assets/image-20250409151301762.png)

真题2

![image-20250409151247621](assets/image-20250409151247621.png)

真题3

![image-20250409151600015](assets/image-20250409151600015.png)

真题4

![image-20250409151753594](assets/image-20250409151753594.png)

7.类图中c3哪里直接理解为泛化，可能就是出题人出错了，正常泛化是空心箭头，这里是实心箭头，我以为是单向关联，所以当一个题目无从下手，被迫考虑一下有没有能当成泛化存在的类，一般都是两个箭头指向一个，且这个题的多重度有问题，一张发票怎么可能对应多个病人。**还要注意问必要属性就像下面这么回答，不是问的数据库里的主键**

有难度，因为出题有问题且泛化写的像单向关联

2019下（里面红色标注可以看看，有学习意义）

![image-20250411113325877](assets/image-20250411113325877.png)

问题3标准答案如下

![image-20250411113819363](assets/image-20250411113819363.png)



## 第七章.计算机网络

### 1.网络的设备

- 物理层：中继器、集线器（可以看作成一种特殊的**多路或多端口**的中继器）
- 数据链路层：网桥、交换机（可以看成**多端口**的网桥）
- 网络层：路由器、ICMP（控制报文协议）
- 应用层：网关

|                      | 广播域 | 冲突域 |
| :------------------: | :----: | :----: |
|   物理层（集线器）   |   ×    |   ×    |
| 数据链路层（交换机） |   ×    |   √    |
|   网络层（路由器）   |   √    |   √    |

真题

![image-20250421200757492](assets/image-20250421200757492.png)

![image-20250421201753328](assets/image-20250421201753328.png)

![image-20250421202128026](assets/image-20250421202128026.png)

![image-20250421202426157](assets/image-20250421202426157.png)

![image-20250421202549865](assets/image-20250421202549865.png)

![image-20250421202632919](assets/image-20250421202632919.png)

### 2.协议簇



​										<img src="../zst讲义—作者：理想/assets/1685079630978-b652f779-54ff-4718-8113-e4692be411a9.png" style="zoom:50%;" />

**这个图是重点**												<img src="assets/1685079609574-90013942-1227-46ba-b363-9c059875d831.png" style="zoom:50%;" />

- **FTP的端口号：20（数据端口）、21（控制端口）**
- http的端口号：80
- **https的端口号：443**
- DNSD的端口号：53
- UDP和TCP属于IP，是传输层

**所有带T的除了TFTP其他都是TCP，所有不带T的除了POP3其他都是UDP**

带ip的加上ARP,RARP都是网络层，

真题

![image-20250421203500776](assets/image-20250421203500776.png)

![image-20250421203708909](assets/image-20250421203708909.png)

![image-20250421204552441](assets/image-20250421204552441.png)

![image-20250421204801506](assets/image-20250421204801506.png)

![image-20250421205000474](assets/image-20250421205000474.png)



### 3.TCP和UDP

- TCP（传输控制协议）：在IP提供的不可靠数据服务的基础上为应用程序**提供了可靠的、面向连接**的、全双工的数据传输服务。采用**三次握手**来确认建立和关闭连接是否成功。TCP的功能或服务有：
  - 可靠传输
  - 连接管理
  - 差错校验和重传
  - 流量控制：采用可变大小的滑动窗口协议
  - 拥塞控制
  - 端口寻址
- UDP（用户数据报协议）：**是一种不可靠的、无连接的协议**，可以保证应用程序进程间的通信。UDP上的应用有VoIP等。
  - UDP的首部8B，TCP的首部20B，UDP相比TCP来说，开销较小。
  - TCP和UDP均提供了端口寻址功能。

补充：

1. TCP和UDP都是应用于**传输层**的网络协议。
2. TCP有助于提供可靠性，UDP有助于提高传输的高速率性。

**真题**

![image-20250421210134191](assets/image-20250421210134191.png)

![image-20250421210319679](assets/image-20250421210319679.png)

![image-20250421210642492](assets/image-20250421210642492.png)

![image-20250421210751099](assets/image-20250421210751099.png)

![image-20250421210840357](assets/image-20250421210840357.png)

### 4.电子邮件协议 SMTP 和 POP3

- SMTP和POP3都使用TCP端口传输和接收邮件。

- SMTP：**邮件发送/传输协议**，仅传输 ASCII 文本，不能传输非文字性附件。主要用来发邮件，**可以使用MIME（邮件附件扩展协议），添加如.mp4，.mp3等其他类型的附件**。**TCP端口号：25**。

- POP3：**邮件接收协议**；**TCP端口号：110**。

- POP3和SMTP都基于C/S模式（Client/Server模式，客户端/服务器模式）。

- PEM：私密邮件

  **真题**

![image-20250421213224820](assets/image-20250421213224820.png)

![image-20250421213402792](assets/image-20250421213402792.png)

![image-20250421213643816](assets/image-20250421213643816.png)

### 5.ARP和RARP

- **地址解析协议**（ARP）和**反地址解析协议**（RARP）是**网络层**的一个重要的协议

- ARP（地址解析协议）：将IP地址转换为MAC地址（物理地址）。

  IP地址转换为MAC地址的转换过程：

  1. 查询ARP高速缓存中是否有该IP地址
  2. 如果该IP地址在ARP高速缓存中，便使用与它对应的MAC地址，将数据报发送给所需的物理网卡
  3. 如果ARP高速缓存中没有该IP地址，ARP便在局域网上以**广播**方式发送一个ARP请求包
  4. 如果局域网上IP地址与某台计算机中的IP地址相一致，那么该计算机便生成一个ARP应答信息（单播），信息中包含对应的MAC地址。（广播传送请求，单播传送响应）

- RARP（反地址解析协议）：将MAC地址转换为IP地址，主要用于无盘工作站。

**真题**

![image-20250421214347917](assets/image-20250421214347917.png)

![image-20250421214433121](assets/image-20250421214433121.png)





### DHCP（动态主机配置协议）（应该不考）

- DHCP协议的功能和作用是：

  - 集中的管理、自动分配IP地址
  - **使网络环境中的主机动态地获得IP地址、Gateway地址（就是网关地址）、DNS服务器地址等信息**
  - 提升地址的使用率

  DHCP客户端可以从DHCP服务器获得以下内容：

  - **本机IP地址（就是客户端地址）**
  - DNS服务器地址
  - DHCP服务器地址
  - 默认网关的地址

  无效地址：

  - Windows无效地址：169.254.X.X

    169.254.X.X是Windows系统在DHCP信息租用失败时自动给客户机分配的IP地址

  - Linux无效地址：0.0.0.0

**真题**

![image-20250421214752358](assets/image-20250421214752358.png)

![image-20250421215111482](assets/image-20250421215111482.png)

![image-20250421215224934](assets/image-20250421215224934.png)

### URL

`协议名://主机名.域名.域名后缀.域名分类/目录/网页文件` 

如软考官网 :https://www.ruankao.org.cn 然后后面是目录及目录下的文件，**域名及域名后缀及域名分类都可以是域名组成部分**

| 组织模式 |       含义       | 地理模式 |   含义   |
| :------: | :--------------: | :------: | :------: |
|   com    |     商业机构     |    cn    |   中国   |
|   edu    |     教育机构     |    hk    | 中国香港 |
|   gov    |     政府机构     |    mo    | 中国澳门 |
|   mil    |     军事部门     |    tw    | 中国台湾 |
|   net    | 主要网络支持中心 |    us    |   美国   |
|   org    |   上述以外组织   |    uk    |   英国   |
|   int    |     国际组织     |    jp    |   日本   |

**IPv6 128位地址空间、IPv4 32位地址空间。**

**真题**

![image-20250421215935270](assets/image-20250421215935270.png)

![image-20250421220002814](assets/image-20250421220002814.png)

![image-20250421220134810](assets/image-20250421220134810.png)

![image-20250421220206562](assets/image-20250421220206562.png)

![image-20250421220243741](assets/image-20250421220243741.png)

![image-20250421220309154](assets/image-20250421220309154.png)



### 浏览器

- DNS域名查询次序是：本地的hosts文件——本地DNS缓存——本地DNS服务器——根域名服务器
- 主域名服务器在接受域名请求后查询顺序是：本地缓存——本地hosts文件——本地数据库——转发域名服务器

**真题**

![image-20250422194622626](assets/image-20250422194622626.png)

![image-20250422194757112](assets/image-20250422194757112.png)

![image-20250422195128622](assets/image-20250422195128622.png)

### internet地址

Internet地址格式主要有两种书写形式，由四个字节，32个比特位组成：

- 域名
- IP地址，如129.102.4.11

域名和ip地址一一对应，只是域名更方便记忆

#### IP地址

IP地址：Internet中的主机地址实际上是用IP地址来唯一标识的。

IP地址有两种：

- IPv4
- IPv6

> 通常IP地址是指IPv4。

#### IPv4

每个IPv4地址都由4个小于256的数字组成（每个数字8位，共32位），数字之间用`.`分开，可分为5类：

![](assets/17.png)

![image-20250422204810357](assets/image-20250422204810357.png)

补充：

- 在IPv4中，全`0`代表的是网络地址，全`1`代表的是广播地址，主机地址无论在哪一类都要-2，因为全零和全1不属于主机地址。

- IPv4能表示的地址个数为：2^32^≈40亿。

#### 子网掩码（子网掩码不看，8年没考过了，计算看不懂 ）

网络软件和路由器使用**子网掩码**来识别报文是仅存放在网络内部还是被路由转发到其他地方。

子网掩码是用来指明特定的IP地址中的网络号和主机号部分。子网掩码的格式与IP地址相同：

- 所有对应网络号的部分用`1`填上；
- 所有对应主机号的部分用`0`填上。
- **划分网要借主机号，假如借了就是2的三次方个子网；聚网要借网络号，真题1和真题3，5用到了，最近是16年考到，应该不会考**

比如c类的子网掩码，前二十四位是网络地址，所以全为1，后8位为主机地址，所以全为0，8位分隔，所以计算出来如下的c类

<img src="assets/18.png">

真题

![image-20250422203639202](assets/image-20250422203639202.png)

![image-20250422203814755](assets/image-20250422203814755.png)

![image-20250422204603474](assets/image-20250422204603474.png)

![image-20250422205147085](assets/image-20250422205147085.png)

![image-20250422205652165](assets/image-20250422205652165.png)

#### IPv6

IPv6具有长达128位的地址空间，可以彻底解决IPv4地址不足的问题。

IPv6理论上能表示的地址个数：2^128^=3.4×10^38^，就是2的128次方，ipv4是2的32次方

> 在想象得到的将来，IPv6的地址空间是不可能用完的。

真题

![image-20250422210733241](assets/image-20250422210733241.png)

![image-20250422210833886](assets/image-20250422210833886.png)

#### 无线通信技术

流行的无线通信技术有WiFi、蓝牙等。其中，蓝牙覆盖范围最小、通信距离最短。

真题

![image-20250422210955067](assets/image-20250422210955067.png)

![image-20250422211006952](assets/image-20250422211006952.png)

### window命令

- ipconfig用于查询本机IP信息。
- traceroute：是Linux下的命令，对应windows命令为tracert路由跟踪命令
- netstat：是一个监控TCP/IP网络的非常有用的工具。它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息
- nslookup：域名查询命令，用于查询DNS解析域名记录
- 网络出现问题时候，优先ping 127.0.0.1，其次ping本地ip，然后是默认网关

![image-20250422211243403](assets/image-20250422211243403.png)

真题

![image-20250422212726498](assets/image-20250422212726498.png)

![image-20250422212733357](assets/image-20250422212733357.png)

![image-20250422212757260](assets/image-20250422212757260.png)

![image-20250422212842122](assets/image-20250422212842122.png)、

![image-20250422212851269](assets/image-20250422212851269.png)

![image-20250422212858789](assets/image-20250422212858789.png)

![image-20250422212906079](assets/image-20250422212906079.png)

### 路由器（基本不考）

![image-20250422213046723](assets/image-20250422213046723.png)

![image-20250422213054376](assets/image-20250422213054376.png)

真题

![image-20250422214315162](assets/image-20250422214315162.png)

![image-20250422214323438](assets/image-20250422214323438.png)

![image-20250422214332637](assets/image-20250422214332637.png)

![image-20250422214339393](assets/image-20250422214339393.png)

![image-20250422214347751](assets/image-20250422214347751.png)

### HTML（题目太老了 ）

真题

![image-20250422214521072](assets/image-20250422214521072.png)

![image-20250422215151045](assets/image-20250422215151045.png)

![image-20250422215221570](assets/image-20250422215221570.png)

![image-20250422215237691](assets/image-20250422215237691.png)

### linux（考的不多）

![image-20250422215454280](assets/image-20250422215454280.png)

## 第八章.信息安全（考五分）

#### 1.防火墙技术

防火墙是建立在**内外网络边界上的过滤封锁机制**。

补充内容

- 防火墙工作层次越低，工作效率越高，安全性越低
- DMZ的作用是保存一些公共服务器（Web服务器、Eamil服务器），可以理解为中间层
- 防火墙的安全性从高到底：内网-------DMZ--------外网
- 防火墙不能提供漏洞扫描，查毒等功能

1. 包过滤防火墙
   - 过滤型的防火墙通常是直接转发报文，它对用户完全透明，速度较快。对**网络层**的数据报文进行检查。处在网络层（TCP）和数据链路层（IP）
   - 优点：防火墙对每条传出网络的包实行低水平控制。每个IP字段都被检查，包含：**源地址、目标地址、协议和端口号**
   - 缺点：不能防范黑客攻击、不支持应用层协议、不能处理新的安全威胁。

2. 应用代理网关防火墙
   - 内网用户对外网的访问变成防火墙对外网的访问，然后再由防火墙转发给内网用户。处在应用层、传输层和网络层。
   - 优点：检查应用层、传输层和网络层的协议特征对数据包的检测能力比较强，安全性高
   - 缺点：难以配置、处理速度非常慢（网络整体性能低）

3. 状态检测技术防火墙
   - 状态检测技术防火墙结合了代理防火墙的安全性和包过滤防火墙的高速度等优点。在不损失安全性的基础上，提高了代理防火墙的性能

**真题**

![image-20250424201510679](assets/image-20250424201510679.png)

![image-20250424212526156](assets/image-20250424212526156.png)

![image-20250424212536383](assets/image-20250424212536383.png)

![image-20250424212547870](assets/image-20250424212547870.png)

![image-20250424212555693](assets/image-20250424212555693.png)

#### 2.病毒

计算机病毒可以分为：

- 文件型计算机病毒：可以感染可执行文件（exe和com文件）
- 引导型计算机病毒：影响软盘或硬盘的引导扇区
- 宏病毒：感染的对象是使用某些程序创建的文本文档（docx，excel）、数据库、电子表格等文件，
- 目录型计算机病毒：可以修改硬盘上储存的所有文件的地址

计算机病毒的特征包括:传播性、破坏性、隐蔽性、感染性、潜伏性、触发性等。

worm表示蠕虫病毒、Trojan表示特洛伊木马（秘密潜伏且能够通过远程网络进行控制的恶意程序）、Backdoor表示后门病毒、Macro表示宏病毒

- 木马软件: 冰河、X卧底


- 蠕虫病毒: 欢乐时光、熊猫烧香、红色代码、爱虫病毒、震网


补充病毒与木马的区别

【病毒】：

- 破坏者——人为的，可自我复制的
- 具有：潜伏性、传染性、隐蔽性、破坏性、多样性、条件触发性

【木马】：

- 盗窃者
- 不产生图标、伪装成“系统服务”的方式、自动运行、具备自动恢复、能自动开启端口，建立网络连接

**真题**

![image-20250424213924483](assets/image-20250424213924483.png)

![image-20250424213937946](assets/image-20250424213937946.png)

![image-20250424213947060](assets/image-20250424213947060.png)

![image-20250424213956287](assets/image-20250424213956287.png)

#### 3.网络攻击

1. 主动攻击：拒绝服务攻击（Dos）、分布式拒绝服务（DDos）、认证处理、信息篡改、资源使用、欺骗、伪装、重放等
2. 被动攻击：嗅探、信息收集等

- **拒绝服务攻击 (Dos攻击) : 目的是使计算机或网络无法提供正常的服务（拒绝服务攻击是不断向计算机发起请求来实现的）。**
- **重放攻击: 攻击者发送一个目的主机已经接受过的报文来达到攻击目的。攻击者利用网络监听或者其他方式盗取认证凭据，之后再重新发送给认证服务器。主要用于身份认证过程，目的是破坏认证的正确性。**
- 口令入侵攻击:使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动。
- 特洛伊木马:被伪装成程序或游戏，当用户下载了带有木马的软件或附件时，这个程序就会向黑客发起连接请求，建立连接后黑客就实施攻击活动。
- 端口欺骗攻击: 采用端口扫描找到系统漏洞从而实施攻击。
- 网络监听: 攻击者可以接收某一网段在同一条物理通道上传输的所有信息使用网络监听可以轻松截取包括账号和口令在内的信息资料。
- IP欺骗攻击（ARP攻击属于Ip攻击）: 产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份。（ARP）
- sql注入攻击: 是黑客对数据库进行攻击的常用手段之一。没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。攻击者可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据首先获取数据库的权限，就可获取用户账号和口令信息，以及对某些数据修改等。
- 入侵检测（用户的非授权访问）技术: 专家系统、模型检测、简单匹配。

**真题**

![image-20250424215846757](assets/image-20250424215846757.png)

![image-20250424215857472](assets/image-20250424215857472.png)

![image-20250424215910462](assets/image-20250424215910462.png)

![image-20250424215920089](assets/image-20250424215920089.png)

![image-20250424215927208](assets/image-20250424215927208.png)



#### 4.网络安全

- SSL是**传输层安全协议，安全加密**，用于实现web的安全通信，端口号443，是远程登陆协议，telnet是不安全登录协议。
- TLS是IETF制定的协议，是SSL的后续版本
- **安全连接的协议是SSH**，也是传输层基础上的安全协议，SSH终端设备与远程站点之间建立安全连接
- HTTPS是使用SSL加密算法的HTTP，等于http+ssl
- MIME多用途互联网**电子邮件附件扩展类型**。扩展了电子邮件的标准，使其能够支持更多的文本，与
- PGP是一个基于RSA公钥加密体系的**邮件加密软件**
- IPSes为IP数据报文进行加密
- RFB远程登录图形化界面，IGMP因特网组管理器
- 内部网关协议：RIP、OSPF   外部网关协议：BGP
- 漏洞扫描系统不能发现网络入侵者，黑客可以利用漏洞系统找到你主机的安全漏洞

![image-20250424223504356](assets/image-20250424223504356.png)

#### 5.安全需求

- 物理线路安全：机房安全
- 网络安全：入侵检测
- 系统安全：漏洞补丁
- 应用安全：数据库安全

**真题**

**![image-20250424223536592](assets/image-20250424223536592.png)**

![image-20250424223545944](assets/image-20250424223545944.png)

![image-20250424223608246](assets/image-20250424223608246.png)



![image-20250424223619126](assets/image-20250424223619126.png)

![image-20250424223625591](assets/image-20250424223625591.png)

![image-20250424223632494](assets/image-20250424223632494.png)

![image-20250424223643470](assets/image-20250424223643470.png)

![image-20250424223654964](assets/image-20250424223654964.png)

杂题

![image-20250424223739274](assets/image-20250424223739274.png)

![image-20250424223744674](assets/image-20250424223744674.png)



## 第九章 软件工程（约10分）

### 1.软件过程

##### 1. 能力成熟度模型（CMM）

CMM 将软件过程改进分为以下5个成熟度级别：

1）初始级（最低成熟度）

软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，**项目的成功完全依赖个人的努力和英雄式核心人物的作用。**

2）可重复级

建立了基本的项目管理过程和实践来**跟踪项目费用、进度和功能特性**，有必要的过程准则来重复以前在同类项目中的成功。

3）已定义级

管理和工程两方面的**软件过程已经文档化、标准化**，并综合成整个软件开发组织的**标准软件过程**。

4）已管理级

制定了软件过程和**产品质量**的详细度量标准。**软件过程的产品质量都被开发组织的成员所理解和控制。**

5）优化级（最高成熟度）

加强了定量分析，通过来自**过程质量**反馈和来自**新观念、新技术**的反馈使过程能不断持续地改进。

##### 2. 能力成熟度模型集成（CMMI）

CMMI 提供了两种表示方法：

1）阶段式模型（没考过）

阶段式模型的结构类似于 CMM，它关注组织的成熟度。

有五个成熟度等级：

- 初始的：过程不可预测且缺乏控制。
- 已管理的：过程为项目服务。
- 已定义的：过程为组织服务。
- 定量管理的：过程已度量和控制。
- 优化的：集中于过程改进。

2）连续式模型**（考的多）**

连续式模型关注每个过程域的能力，一个组织对不同的过程域可以达到不同的过程域能力。

CMMI 中包括6个过程域能力等级：cl就是capability level

- CL₀（未完成的）：过程域**未执行**或**未得到** CL₁ 中定义的所有目标。
- CL₁（已执行的）：其共性目标是过程将可标识的**输入工作产品转换成可标识的输出工作产品**，以实现支持**过程域的特定目标**。
- CL₂（己管理的）：其共性目标**集中于己管理的过程的制度化**。根据组织级政策规定 过程的运作将使用哪个过程，项目遵循己文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审。
- CL₃（己定义级的)：其共性目标**集中于己定义的过程的制度化**。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。
- CL₄(定量管理的)：**其共性目标集中于可定量管理的过程的制度化**。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。
- CL₅（优化的)：**使用量化（统计学）手段改变和优化过程域**，以满足客户要求的改变和持续改进计划中的过程域的功效。

### 2.软件过程模型

软件开发过程模型是指为了有效地开发、维护和更新软件系统，提出的一系列步骤、阶段和方法的系统框架，以实现提高软件质量、加快开发速度和降低开发成本的目的。

常见的软件开发过程模型包括瀑布模型、增量模型、演化模型（原型模型、螺旋模型）和喷泉模型。

#### 瀑布模型

瀑布模型是一种线性的软件开发过程模型，开发流程严格按照顺序依次进行，每个阶段都必须完成后才能进入下一个阶段。瀑布模型包括需求分析、设计、编码、测试和维护五个阶段。

瀑布模型：

- 优点：

  - 容易理解、管理成本低
  - 每个阶段都有对应的成果产物
  - 各个阶段有明显的界限划分和顺序需求
  - 强调开发的阶段性早期计划及需求调查和产品测试

- 缺点：

  - 需要客户能够完整、正确和清晰地表达自己的需要

  - 在开始的两个或3个阶段中，很难评估真正的进度状态

  - 当接近项目结束时，出现了大量的集成和测试工作

  - 直到项目结束之前，都不能演示系统的能力

  - 一旦发生错误，整个项目要推到重新开始。

  - 需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算

瀑布模式适合用于：

- **开发需求明确的，需求大致固定且不会随意变更的系统**

- **开发人员对软件的应用领域很熟悉**

- **开发工作对用户参与的要求很低**

  一般提到了v模型就选瀑布模型

![image-20250425204759231](assets/image-20250425204759231.png)

**真题**

![image-20250425213445003](assets/image-20250425213445003.png)

![image-20250425213457797](assets/image-20250425213457797.png)

![image-20250425213504543](assets/image-20250425213504543.png)

#### 增量模型

![image-20250425205652126](assets/image-20250425205652126.png)

增量模型采用了逐步完善的思路，将软件的开发过程划分为一个个的增量，每个增量都能够独立实现  某一或多项功能或特性。在逐步实现的过程中，可以不断根据需求变化来进行迭代，从而保证最终的软件达到客户需求和期望。

**增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点**。此外，它还有以下优点：

- 第一个可交付版本所需要的成本和时间很少
- 开发由增量表示的小系统所承担的风险不大
- 由于很快发布了第一个版本，因此可以减少用户需求的变更
- 优先级高的功能先交付，使得重要的功能经历更多的测试
- 运行增量投资，即在项目开始时，可以仅对一个或两个增量投资
- 可以使用早期增量作为原型进行后续开发

缺点：

- **如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定**
- 如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发、重新发布
- **管理发生的成本、进度和配置的复杂性可能比较大**



量模型适合用于：

- 需求尚不明确
- 需要快速构造可运行的产品的项目（对完成期限严格要求的产品）适宜商业开发
- 进行已有产品升级或新版本开发
- 对所开发的领域比较熟悉而且已有原型系统。

**真题**

![image-20250425213519865](assets/image-20250425213519865.png)

![image-20250425213535092](assets/image-20250425213535092.png)

![image-20250425213542855](assets/image-20250425213542855.png)





#### 演化模型

演化模型是迭代的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。**演化模型特别适用于对软件需求缺乏准确认识的情况**，**允许在开发过程中逐步完善功能**。典型的演化模型有原型模型和螺旋模型等。

##### 原型模型

并非所有的需求都能够预先定义。大量的实践表明，在开发初期很难得到一个完整的、准确的需求规格说明。原因有：

- 客户往往不能准确地表达对未来系统的全面要求，导致形成的需求规格说明不完整、不准确，甚至是有歧义。
- 在整个开发过程中，用户可能会产生新的要求，导致需求的变更。 

原型模型：

- **适合于用户需求不清、需求经常变化的情况**

- **不适合大规模系统的开发**

  

原型的目的是能快速、低成本地构建原型系统。

能够采用原型方法是因为开发工具的快速发展，使得能够迅速地开发出一个让用户看得见、摸得着的系统框架。这样，对于计算机不是很熟悉的用户就可以根据这个框架提出自己的需求。

开发原型系统首先确定用户需求，开发初始原型，然后征求用户对初始原型的改进意见，并根据意见修改原型:

<img src="assets/13.png">

1. 交流：目的是定义软件的总体目标，标识需求，然后
2. 快速计划：快速制订原型开发的计划，确定原型的目标和范围
3. 采用快速设计方式进行建模
4. 构建原型
5. 部署交付和反馈：被开发的原型应交付给客户使用，并收集客户的反馈意见，这些反馈意见可在下一轮中对原型进行改进
6. 下一轮迭代：在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发

根据使用原型的目的不同，原型可以分为：

- 探索型原型：目的是要弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性。
- 实验型原型：目的是验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。
- 演化型原型：目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。

**真题**

![image-20250425213622918](assets/image-20250425213622918.png)



##### 螺旋模型

对于复杂的大型软件，开发一个原型往往达不到要求。

螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析（以风险为驱动），弥补了这两种模型的不足。

螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合：

<img src="assets/14.png">

螺旋模型属于面向对象开发模型。

螺旋模型适用于：

- **庞大、复杂，高风险并且具有高风险的系统；**
- 新近开发，需求不明的情况。

优点：

- 支持用户需求的动态变化
- 螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。
- 螺旋模型支持用户需求的动态变化，有助于提高软件的适应能力，降低了软件开发的风险。

缺点：

- 需要开发人员具有相当丰富的风险评估经验和专门知识。
- 过多的迭代次数会增加开发成本，延迟提交时间。

**真题**

![image-20250425213701421](assets/image-20250425213701421.png)

![image-20250425213654771](assets/image-20250425213654771.png)



#### 喷泉模型

喷泉模型：喷泉模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性

- 以用户需求为动力
- 以对象作为驱动
- 适合于面向对象

喷泉模型使开发过程具有以下性质或特点：

- **迭代性**：意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统。

- **无间隙性**：指在开发活动（如分析、设计、编码）之间不存在明显的边界。

  喷泉不像瀑布模型那样，在需求分析活动结束后才开始设计活动，在设计活动结束后才开始编码活动，而是允许各开发活动交叉、迭代地进行。

  **喷泉模型的各个阶段没有明显的界线**，开发人员可以同步进行。

- **支持软件重用**。

优点：可以提高软件项目的开发效率，节省开发时间。

缺点：

- 由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，不利于项目的管理。
- 喷泉模型要求严格管理文档，使得审核的难度加大。

**真题**

![image-20250425213727802](assets/image-20250425213727802.png)



### 统一过程（UP）模型(14年后没考过)   

![image-20250425212626430](assets/image-20250425212626430.png)

|   阶段   |    里程碑    |        关注        |                   产生                   |
| :------: | :----------: | :----------------: | :--------------------------------------: |
| 初始阶段 | 生命周期目标 |   项目的初创活动   |  构想文档、业务用例、项目计划、风险评估  |
| 精化阶段 | 生命周期架构 | 需求分析和架构演进 | 补充需求分析、软件架构描述、架构原型制品 |
| 构建阶段 | 初始运作功能 |     系统的构建     |        具有最初运作能力的软件产品        |
| 移交阶段 |   产品发布   | 软件提交方面的工作 |               产品发布版本               |

**真题**

![image-20250425213751910](assets/image-20250425213751910.png)

![image-20250425213758357](assets/image-20250425213758357.png)



### 敏捷方法（考的算多）

敏捷方法是一种反应灵活、拥有高度互动性和以人为本的软件开发方法。它的核心是通过不断地交付成果和及时反馈，来满足客户需求和不断变化的业务环境。以下是敏捷方法中的一些常见实践：

- 极限编程（XP）
- 水晶法（Crystal）
- 并列争求法（Scrum）
- 自适应软件开发（ASD）
- 敏捷统一过程（AUP）

#### 极限编程（XP）（考的多）

极限编程是为了降低需求变更所带来的成本，旨在提高软件质量和对客户需求变化的适应性，期望能够让软件开发达到低成本、低缺陷、高产出、高回报（最小投入得到最大结果）的效果。

极限编程（XP）软件开发方式有以下性质：

- 轻量级（敏捷）
- 高效
- 低风险
- 柔性
- 可预测的
- 科学的

XP由价值观、原则、实践和行为4个部分组成，他们之间彼此相互依赖、关联，并通过行为贯穿于整个生存周期：

- 4大价值观：
  - 沟通
  - 简单性
  - 反馈
  - 勇气
- 5个原则：
  - 快速反馈
  - 简单性假设
  - 逐步修改
  - 提倡更改
  - 优质工作
- 12个最佳实践：
  - 计划游戏：快速制定计划、随着细节的不断变化而完善
  - 小型发布：系统的设计要能够尽可能早地交付
  - 隐喻：找到合适的比喻传达信息
  - 简单设计：只处理当前的需求，使设计保持简单
  - 测试先行：先写测试代码，然后再编写程序
  - 重构：重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求
  - 结对编程：非正式的代码审查，以获得质量更高的代码
  - 集体代码所有制：任何开发人员都可以对系统的任何部分进行改进
  - 持续集成：可以按日甚至按小时为客户提供可运行的版本
  - 每周工作40个小时
  - 现场客户：系统最终用户代表应该全程配合XP团队
  - 编码标准

#### 水晶法（Crystal）

- **认为每一个不同的项目都需要一套不同的策略、约定和方法论**。（这个概念考了很多次）
- 认为人对软件质量有重要的影响。随着项目质量和开发人员素质的提高，项目和过程的质量也随之提高。
- 通过更好地交流和经常性的交付，软件生产力得到提高。

#### 并列争求法（Scrum）

使用迭代的方法。

- **把每30天一次的迭代称为一个“冲刺”。**
- 按需求的优先级别来实现产品。
- 多个自组织和自治的小组并行地递增实现产品。
- 协调是通过简短的日常情况会议来进行，就像橄榄球中的“并列争球”。

#### 自适应软件开发（ASD）

有6个基本原则：

- 有一个使命作为指导；
- 特征被视为客户价值的关键点；
- 过程中的等待是很重要的，因此“重做”与“做”同样关键；
- 变化不被视为改正，而是被视为对软件开发实际情况的调整；
- 确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求；
- 风险也包含其中。

#### 敏捷统一过程（AUP）

敏捷统一过程采用以下原理来构建软件系统：

- “在大型上连续”
- “在小型上迭代”。

采用经典的UP阶段性活动（初始、精化、构建和转换），提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。

在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。每个AUP迭代执行以下活动：

- **建模**：建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进。
- **实现**：将模型翻译成源代码。
- **测试**：像XP一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求。
- **部署**：对软件增量的交付以及获取最终用户的反馈。
- **配置及项目管理**：着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动。
- **环境管理**：协调标准、工具以及适用于开发团队的支持技术等过程基础设施。

### 3.软件需求(考的少)

软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。通常，这些需求包括：

- **功能需求**：考虑系统要做什么，在何时做，在何时以及如何修改或升级。

- **性能需求**：考虑软件开发的技术性指标。

  - 存储容量限制；
  - 执行速度；
  - 响应时间；
  - 吞吐量。

- **用户或人的因素**：考虑用户的类型。

  - 各种用户对使用计算机的熟练程度，需要接受的训练；
  - 用户理解、使用系统的难度；
  - 用户错误操作系统的可能性。

- **环境需求**：考虑未来软件应用的环境，包括硬件和软件。

  - 对硬件设备的需求包括：机型、外设、接口、地点、分布、湿度、磁场干扰等；
  - 对软件的需求包括：操作系统、网络、数据库等。

- **界面需求**：

  - 来自其他系统的输入；
  - 到其他系统的输出；
  - 对数据格式的特殊规定；
  - 对数据存储介质的规定。

- **文档需求**：考虑需要哪些文档，文档针对哪些读者。

- **数据需求**：

  - 输入、输出数据的格式；
  - 接收、发送数据的频率；
  - 数据的准确性和精度；
  - 数据流量；
  - 数据需保持的时间。

- **资源使用需求**：

  - 软件运行时所需要的数据、其他软件、内存空间等资源；
  - 软件开发、维护时，所需的人力、支撑软件、开发设备。

- **安全保密要求**：

  - 是否需要对访问系统或系统信息加以控制；
  - 隔离用户数据的方法；
  - 用户程序如何与其他程序和操作系统隔离
  - 系统备份要求。

- **可靠性要求**：

  - 系统的可靠性要求；
  - 系统是否必须检测和隔离错误；
  - 出错后，重启系统允许的时间。

- **软件成本消耗与开发进度需求**：

  - 开发是否有规定的时间表；
  - 软/硬件投资有无限制。

- **其他非功能性要求**：

  如采用某种开发模式，需要确定：

  - 质量控制标准；
  - 里程碑和评审；
  - 验收标准；
  - 各种质量要求的优先级；
  - 可维护性方面的要求。

软件需求的出处：

- 可以来自于用户（实际的和潜在的）、用户的规约、应用领域的专家、相关的技术标准和法规；
- 可以来自于原有的系统、原有系统的用户、新系统的潜在用户；
- 可以来自于竞争对手的产品

**真题**

![image-20250426143141116](assets/image-20250426143141116.png)

### 4.系统设计

#### 1.概要设计

1. 设计软件系统总体结构 

   - 确定每个模块的功能
   - 确定模块之间的调用关系
   - 确定模块之间的接口
2. 数据结构及数据库设计
3. 编写概要设计文档
4. 评审

#### 2.详细设计

1. **对每个模块进行详细的算法设计**
2. 对模块内的数据结构进行设计
3. 对数据库进行物理设计
4. 其他设计
   1. 代码设计
   2. 输入输出格式设计
   3. 用户界面设计
5. 编写详细设计说明书
6. 评审

#### 3.编码

根据详细设计进行代码的编写，得到可以运行的软件，并进行单元测试。

**真题**

![image-20250426162625486](assets/image-20250426162625486.png)

![image-20250426162630872](assets/image-20250426162630872.png)

### 5.测试

#### 1.系统测试 

**意义**：系统测试是为了发现错误而执行程序的过程，**成功的测试是发现了至今尚未发现的错误的测试**。
**目的**：测试的目的就是**希望能以最少的人力和时间发现潜在的各种错误和缺陷**。

**系统测试原则**

1. 应尽早并不断地进行测试。
2. 测试工作应该避免由原开发软件的人或小组承担。
3. 在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。
4. **在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件**。
5. 在测试程序时，不仅要检验程序是否做了该做的事，还要校验程序是否做了不该做的事。
6. 严格按照测试计划来进行，避免测试的随意性。
7. 妥善保存测试计划、测试用例。
8. 测试用例都是精心设计出来的。
9. **系统测试阶段的测试目标来自于需求分析阶段**。

**真题**

![image-20250426162703943](assets/image-20250426162703943.png)

![image-20250426162730818](assets/image-20250426162730818.png)

![image-20250426162736539](assets/image-20250426162736539.png)

#### 2.单元测试（模块测试）

**13年后没考过**

1. 单元测试的测试内容

   1.模块接口

   - 测试模块的输入参数和形式参数在个数、属性、单位上是否一致。
   - 调用其他模块时，所给出的实际参数和被调用模块的形式参数在个数、属性、单位上是否一致。
   - 调用标准函数时，所用的参数在属性、数目和顺序上是否正确。
   - 全局变量在各模块中的定义和用法是否一致。
   - 输入是否仅改变了形式参数。
   - 开/关的语句是否正确。
   - 规定的I/O格式是否与输入/输出语句一致。
   - 在使用文件之前是否已经打开文件或使用文件之后是否己经关闭文件。

   2.局部数据结构

   3.重要的执行路径

   4.出错处理

   5.边界条件

2. 单元测试过程

   - 驱动模块：接收测试例子的数据，将这些数据送到测试模块，输出结果。即模拟被测试模块的上一级模块，相当于被测模块的主程序。
   - 桩模块：代替测试模块中所调用的子模块，其内部可进行少量的数据处理。目的是为了检验入口、输出调用和返回的信息。
   - 提高模块的内聚度可以简化单元测试。

**真题**

![image-20250426162754115](assets/image-20250426162754115.png)

#### 3.集成测试 

**15年后没考过**

集成测试是进行一些旨在发现与接口相关的错误的测试，其目标是利用已通过单元测试的构件建立设计中描述的程序结构。

1. 自顶向下集成测试

​		自顶向下集成测试是一种构造软件体系结构的增量方法，抽象到具体。

> **自顶向下集成不需要驱动模块，需要桩模块**。

2. 自底向上集成测试

​		自底向上集成测试就是从原子模块（程序结构的最底层构件）开始进行构造和测试，具体到抽象。

> **自底向上集成需要驱动模块，不需要桩模块**。

3. **回归测试**：软件发生变更，或修改一个bug后可能会引发新的错雾，重新执行己测试过的某些子集，以确保变更没有传播不期望的副作用。
4. 冒烟测试：一种常用的集成测试方法，是时间关键项目的决定性机制，它让软件团队频繁地对项目进行评估。

**真题**

![image-20250426162819198](assets/image-20250426162819198.png)

![image-20250426162825314](assets/image-20250426162825314.png)

#### 4.测试方法

测试方法分为：

- 静态测试：指被测试程序不在机器上运行，而是采用以下手段对程序进行检测

  - 人工检测：不依靠计算机而是依靠人工审查程序或评审软件。人工检测包括：
    - 代码检查
    - 静态结构分析
    - 代码质量度量
  - 计算机辅助静态分析

- **动态测试**：指通过运行程序发现错误。在对软件产品进行动态测试时可以采用以下两种测试方法：

  - **黑盒测试法**
  - **白盒测试法**

  测试用例由以下组成：

  - 测试输入数据
  - 预期输出结果：与测试输入数据对应的预期输出结果

  在设计测试用例时，应当包括：

  - 合理的输入条件
  - 不合理的输入条件



#### 5.黑盒测试（功能测试）

**考的多**

黑盒测试在完全不考虑软件的内部结构（例如源代码）和特性的情况下，测试软件的外部特性

分类如下：

- **等价类划分**：将程序的输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例，**同时包含一个符合和不符合的就是好的测试用例，当测试用例全是无效等价类或全是有效等价类时则不是一个好的测试用例 **。分类为：
  - 有效等价类
  - 无效等价类
- 边界值分析：输入的边界比中间更加容易发生错误，因此用边界值分析来补充等价类划分的测试用例设计技术。
- 错误推测
- 因果图

**真题**

![image-20250426162839286](assets/image-20250426162839286.png)

![image-20250426162847218](assets/image-20250426162847218.png)

![image-20250426162852383](assets/image-20250426162852383.png)

#### 6.McCabe度量法（边 - 节 + 2）

m就是图中箭头的个数，也可以理解为边的个，n是节点，节点就是下面的a，b，c等等

**如果忘记公式，就数闭环的个数+1，之所以加一，可以理解为图这个整体也是一个环**

<img src="assets/15.png">

**真题**

![image-20250426163059418](assets/image-20250426163059418.png)

![image-20250426163105694](assets/image-20250426163105694.png)

![image-20250426163115414](assets/image-20250426163115414.png)

![image-20250426163124302](assets/image-20250426163124302.png)

#### 7.白盒测试（结构测试）

白盒测试**根据程序的内部结构和逻辑来设计测试用例，需要看源代码**，对程序的路径和过程进行测试，检查是否满足设计的需要。

常用技术包含：

- **逻辑覆盖**：（会同时用到多个测试用例）考察用测试数据运行被测程序时，对程序逻辑的覆盖程度。主要的逻辑覆盖标准有6种，它们的**覆盖程度从低到高**为：

  1. **语句覆盖**：指选择足够的测试数据，使被测试程序中的**每条语句至少执行一次，由于某些地方存在判断，所以可能需要多个测试用例才是实现所有语句至少执行一次的要求**。语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖。![image-20250426155323792](assets/image-20250426155323792.png)![image-20250426163722555](assets/image-20250426163722555.png)

  2. **判定覆盖（分支覆盖）**：指设计足够的测试用例，使得被测程序中的**每个至少获得一次“真”/“假”值**。判定覆盖的判定表达式是指判定表达式整体。判定覆盖要比语句覆盖更强一些，**如上图，只要判断分支的Y和N都至少执行一次就符合判定覆盖，所以也可能不止一个测试用例**。快速做题方法，看下面结果![image-20250426162538122](assets/image-20250426162538122.png)

  3. **条件覆盖**：指构造一组测试用例，使得每一判定语句中每**个逻辑条件的各种可能的值至少满足一次**。

     条件覆盖的判定语句是指判定表达式下的判定语句（如果有），即用`AND`、`OR`等逻辑运算符连接起来的语句（不包含逻辑运算符的语句），**如上图判定表达式中的A>0 AND B>0这两个条件都要分别满足一次真和假，A>1 OR C>1同理，比条件覆盖更细**。

  4. **判定/条件覆盖**：说白了同时满足判定和条件的测试用例组合，指设计足够的测试用例，使得判定中每个条件的所有可能取值（真/假）至少出现一次，并使每个判定本身的判定结果（真/假）也至少出现一次，一般用同真和同时假来实现会好一些。结果取判定覆盖和条件覆盖的并集。

     判定/条件覆盖同时满足：

     - 判定覆盖
     - 条件覆盖

  5. **条件组合覆盖**：指设计足够的测试用例，使得每个**判定中条件的各种可能值的组合都至少出现一次**。![image-20250426161326999](assets/image-20250426161326999.png![image-20250426161528217](assets/image-20250426161528217.png)

     满足条件组合覆盖的测试用例一定满足：

     - 判定覆盖
     - 条件覆盖
     - 判定/条件覆盖

  6. **路径覆盖**：指覆盖被测试程序中**所有可能的路径**，很好理解如上图有四种路径，首先满足A>0 AND B>0和A>1 OR C>1的时一条，互相组合有四种可以输出结果的路径，是覆盖程度最高的。

     ![image-20250426164610562](assets/image-20250426164610562.png)

     ![image-20250426165759295](assets/image-20250426165759295.png)

     ![image-20250426170052254](assets/image-20250426170052254.png)

     ![image-20250426171133076](assets/image-20250426171133076.png)

- 循环覆盖（考的少）

- 基本路径测试（考的少）

白盒测试逻辑覆盖技术总结（**覆盖程度从低到高**）：

|     逻辑覆盖     |                      说明                      |
| :--------------: | :--------------------------------------------: |
|     语句覆盖     |                每条语句执行一次                |
| 分支（判定）覆盖 |           每个分支获得一次True/False           |
|     条件覆盖     | 每个分支中的每个逻辑条件的所有可能取值满足一次 |
|  判定/条件覆盖   |              分支覆盖 + 条件覆盖               |
|   条件组合覆盖   |   每个判定中条件的各种可能值的组合都出现一次   |
|     路径覆盖     |         覆盖被测试程序中所有可能的路径         |

**真题**

![image-20250426164636926](assets/image-20250426164636926.png)

#### 8.白盒结合McCabe度量法(里面的简单路径要了解)

**简单路径就是每次走完一个流程图的时候，语句不能重复，语句就是矩形那个，判断也就是菱形可以重复走**

![image-20250426173352855](assets/image-20250426173352855.png)

![image-20250426173528334](assets/image-20250426173528334.png)

#### 9.伪代码

**1.for循环**

![image-20250426180110677](assets/image-20250426180110677.png)

**2.WHILE**

![image-20250426180139180](assets/image-20250426180139180.png)

**3.DO-WHILE**

![image-20250426180208956](assets/image-20250426180208956.png)



**真题**

![image-20250426180034487](assets/image-20250426180034487.png)

![image-20250426180046517](assets/image-20250426180046517.png)

![image-20250426180720784](assets/image-20250426180720784.png)

![image-20250426182015187](assets/image-20250426182015187.png)

![image-20250426182027365](assets/image-20250426182027365.png)

### 6.运行和维护

#### 1.系统可维护性概念

系统是否能被很好地维护，可以用系统的可维护性这一指标来衡量。

**系统可维护性的评价指标**：

- 可理解性
- 可测试性
- 可修改性

![image-20250426182508341](assets/image-20250426182508341.png)

**软件文档与软件维护**：

**软件文档是软件可维护性的决定因素**。文档是软件产品的一部分，并且编写高质量的文档可以提高软件开发的质量。

软件系统的文档分为：

- 用户文档：主要描述系统功能和使用方法，并不关心这些功能是怎样实现的
- 系统文档：描述系统设计、实现和测试等各方面的内容。

**可维护性是所有软件都应具有的基本特点**，必须在开发阶段保证软件具有可维护的特点。在软件工程的每一个阶段都应考虑并提高软件的可维护性，在每个阶段结束前的技术审查和管理复查中应该着重对可维护性进行复审（如将来要改进的部分和可能会修改的部分）。

做题技巧：

- **维护应该针对整个软件配置，不应该只修改源程序代码**。
- 编写高质量文档可以提高软件开发的质量。
- 文档也是软件产品的一部分，没有文档的软件就不能称之为软件。
- 软件文档的编制在软件开发工作中占有突出的地位和相当大的工作量高质量文档对于软件产品的效益有着重要的意义。
- 总的来说，软件文档只好不坏，选项中**说软件文档不好的就是不正确的**。
- **软件维护的成本很高**

**真题**

![image-20250426182944822](assets/image-20250426182944822.png)

![image-20250426183054681](assets/image-20250426183054681.png)

![image-20250426183122923](assets/image-20250426183122923.png)

![image-20250426183454910](assets/image-20250426183454910.png)

#### 2.系统维护的内容及类型

**软件维护**（考的多，这里贼容易选错）：

- 正确性维护。指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误，**和错误有关就选这个**。
- **适应性维护**。使应用软件适应信息技术变化和**管理需求变化**而进行的修改，**被动改变**。
- **完善性维护**。为扩充功能和**改善提高性能**而进行的修改，**主动改变，这里不好判断就看是否提升性能，提升了就是完善性，不是完善性那就是适应性**。
- 预防性维护。为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬件环境的变化，应**主动增加预防性的新的功能**，以使应用系统适应各类变化而不被淘汰。

![image-20250427220657332](assets/image-20250427220657332.png)

![image-20250427220706759](assets/image-20250427220706759.png)

![image-20250427220714334](assets/image-20250427220714334.png)

![image-20250427220722648](assets/image-20250427220722648.png)

![image-20250427220730334](assets/image-20250427220730334.png)

![image-20250427220735698](assets/image-20250427220735698.png)

#### 3.软件可靠性、可用性、可维护性

- 可靠性、可用性利可维护性是软件的质量属性，软件工程中，用 0-1 之间的数来度量。
- **MT: Mean Time;TF：To Failure; BF: Between Failure; TR: To Repair**
- **可靠性**是指一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率。可以用 **MTTF/(1+MTTF)** 来度量，其中 **MTTF 为平均无故障时间**。
- **可用性**是在给定的时间点上，一个系统能够按照规格说明正确运作的概率。可以用 **MTBF/(1+MTBF)** 来度量，其中 **MTBF 为平均失效间隔时间**。
- **可维护性**是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。可以用 **1/(1+MTTR)** 来度量，其中 **MTTR 为平均修复时间**。

![image-20250427220624663](assets/image-20250427220624663.png)

![image-20250427220640383](assets/image-20250427220640383.png)

### 7.沟通路径

沟通图是指项目中人员或部门之间的沟通用一条无向边连接起来，所构成图即为沟通图。沟通图中的路径称为沟通路径。

软件项目中沟通路径m的计算公式（人数n）：

- 沟通图中无主程序员时：
  $$
  m= (n−1)n÷2//这是等差数列公式
  $$

- 沟通图中有主程序员时：
  $$
  m = n -1
  $$

![image-20250427203422808](assets/image-20250427203422808.png)

**真题**

![image-20250427220805436](assets/image-20250427220805436.png)



### 8.COCOMO 估算模型

COCOMO模型是一种精确的、易于使用的成本估算模型。COCOMO模型按其详细程度分为：

1. 基本COCOMO模型：是一个**静态单变量模型**，用于对整个软件系统进行估算。
2. 中级COCOMO模型：是一个**静态多变量模型**，它将软件系统模型分为系统和部件两个层次，系统由部件构成，它把软件开发所需的人力（成本）看作是程序大小和一系列“成本驱动属性”的函数。
3. 详细COCOMO模型：将软件系统模型分为系统、子系统和模块3个层次，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等每一步的成本驱动属性的影响。

**COCOMOII模型（考的很多）**

和其前身COCOMO一样，COCOMOII也是一种层次结构的估算模型，被分为3个阶段性模型，分别对应三种不同的规模估算选择：

1. 应用组装模型：在软件工程的前期阶段使用，这时用户界面的原型开发、对软件和系统交互的考虑、性能的评估以及技术成熟度的评价是最重要的。

   规模估算选择：**对象点**。

2. 早期设计阶段模型：在需求己经稳定并且基本的软件体系结构己经建立时使用。

   规模估算选择：**功能点**。功能点可转换为代码行。

3. 体系结构阶段模型：在软件的构造过程中使用。

   规模估算选择：**代码行**。

**真题**

![image-20250427220819840](assets/image-20250427220819840.png)

![image-20250427220825663](assets/image-20250427220825663.png)

### 9.图

#### Gantt图

- Gantt图优点：
  - **能清晰地描述每个任务的开始时间**；
  - **能清晰地描述每个任务的结束时间**；
  - **能清晰地描述任务的进展情况**；
  - 各个任务之间的并行性。
- Gantt图缺点：
  - **不能清晰地反映各任务之间的依赖关系**；
  - 难以确定整个项目的关键所在，即**不能清晰地确定影响进度的关键任务**；
  - 不能反映计划中有潜力的部分。

**真题**

![image-20250427220842471](assets/image-20250427220842471.png)

#### PERT图

PERT图是一个有向图：

PERT图的优点：

- 给出了每个任务的开始时间、结束时间和完成该任务所需的时间；
- 给出了任务之间的关系（依赖关系）。即任务之间的执行顺序。

**PERT图不能清晰地描述任务之间的并行情况**。

**一个节点被多个任务指向的时候，当前节点最早时刻是另外几个任务中时刻最大的值**

**关键路径就是用时最长路径，加一下任务持续时间就行**

下图注意分叉节点的最短时间取多个节点较大值，分叉节点最迟时刻取多节点最小值。松弛时间也是注意交叉节点，看图就能理解

![image-20250427213846645](assets/image-20250427213846645.png)

**真题**

![image-20250427220903722](assets/image-20250427220903722.png)

![image-20250427220910996](assets/image-20250427220910996.png)



#### 项目活动图（经常考）

![image-20250427220024872](assets/image-20250427220024872.png)

**想到了松弛时间的直观理解：如果这条路不在关键路径上，走这条路相当于走捷径，只需要算出起点经过这条路到终点的时间，再和关键路径相减就行**

项目活动图是一种有向图（与PERT图十分类似）：

- 弧：表示活动。弧的权值表示活动的持续时间。

- 顶点：表示项目里程碑。

  特殊的里程碑：

  - 开始里程碑：没有任何活动指向该里程碑
  - 结束里程碑：没有任何活动从该里程碑指出

项目活动图的关键路径：**就是持续时间加起来最长的路径**。

关键路径的长度：为结束里程碑的最早时刻（或最晚时刻）。它可以用来表示项目完成的最少时间。

做题技巧 关键路径上的最迟和最早相等，且延迟时间为0

**真题**

![image-20250427222111239](assets/image-20250427222111239.png)

![image-20250427220932041](assets/image-20250427220932041.png)

![image-20250427220948878](assets/image-20250427220948878.png)

![image-20250428201704892](assets/image-20250428201704892.png)

![image-20250428201839308](assets/image-20250428201839308.png)

![image-20250428201919248](assets/image-20250428201919248.png)

**画项目活动图**

**真题**

![image-20250428202035399](assets/image-20250428202035399.png)

![image-20250428202004579](assets/image-20250428202004579.png)

### 10.软件配置管理

![image-20250428202123218](assets/image-20250428202123218.png)**真题**

![image-20250428202204649](assets/image-20250428202204649.png)

### 11.风险(内容多，不好记)

#### 风险管理

一般认为软件风险包含两个特性：

- **不确定性：**指风险可能发生也可能不发生；
- **损失：**指如果风险发生，就会产生恶性后果。

**风险分为以下三种：**

**项目风险**威胁到项目计划。项目风险是指以下各方面的潜在问题以及它们对软件项目的影响：

- 预算
- 进度
- 人员：聘用职员及组织
- 资源
- 利益相关者
- 需求

以下方面的不确定性也属于项目风险因素：

- 项目复杂度
- 项目规模
- 项目结构

**技术风险**威胁到要开发软件的质量及交付时间。技术风险是指以下方面的潜在问题：

- 设计
- 实现
- 接口
- 验证
- 维护

- 规格说明的歧义性
- 技术的不确定性
- 技术陈旧
- **“前沿”技术**

**商业风险**威肋到要开发软件的生存能力，且常常会危害到项目或产品。5个主要的商业风险如下：

- 市场风险：开发了一个没有人真正需要的优良产品或系统。
- 策略风险：开发的产品不再符合公司的整体商业策略。
- 销售风险：开发了一个销售部门不知道如何去销售的产品。
- 管理风险：由于重点的转移或人员的变动而失去了高级管理层的支持。
- 预算风险：没有得到预算或人员的保证。

#### 风险识别

风险识别试图系统化地指出对项目计划（估算、进度、资源分配等）的威胁。识别出已知风险和可预测风险后，项目管理者首先要做的是：

- **在可能时回避这些风险；**
- **在必要时控制这些风险。**

识别风险的一种方法是建立风险条目检查表（未考察），主要用来识别下列几种类型中的一些已知风险和可预测风险：

- 产品规模：与要开发或要修改的软件的总体规模相关的风险。
- 商业影响：与管理者或市场所施加的约束相关的风险。
- 客户特性：与客户的素质以及开发者和客户定期沟通的能力相关的风险。
- 过程定义：与软件过程定义的程度以及该过程被开发组织遵守的程度相关的风险。
- 开发环境：与用来开发产品的工具的可得性及质量相关的风险。
- 开发技术：与待开发软件的复杂性及系统所包含技术的“新奇性”相关的风险。
- 人员才干及经验：与软件工程师的总体技术水平及项目经验相关的风险。

与上述每个主题相关的问题可以针对每一个软件项目来回答。根据这些问题的答案，项目管理者就可以估计风险产生的影响。另一种风险条目检查表格式：仅仅列出与每一种类型有关的特性，最终给出一组风险因素和驱动因子以及它们发生的概率。

风险因素（未考察）包括：

- 性能：性能风险是指产品能够满足需求且符合其使用目的的不确定程度。
- 成本：成本风险是指能够维持项目预算的不确定程度。
- 支持：支特风险是指开发出的软件易于纠错、修改及升级的不确定程度。
- 进度：进度风险是指能够维持项目进度且按时交付产品的不确定程度。

#### 风险预测

风险预测又称风险估计，它试图从两个方面评估一个风险：

- 风险发生的可能性或概率；
- 发生风险所产生的后果。

通常，项日计划人员与管理人员、技术人员一起进行以下4步风险预测活动：

1. 建立一个尺度或标准，以反映风险发生的可能性。
2. 描述风险产生的后果。
3. 估算风险对项目和产品的影响。
4. 标注风险预测的整体精确度，以免产生误解。

一种简单的风险预测技术是建立风险表：

- 第1列：列出所有的风险（由风险识别活动得到)；

- 第2~4列：列出每个风险的：

  - 种类
  - 发生的概率
  - 所产生的影响

  风险所产生的影响可用一个数字来表示：

  - “1”：表示灾难性的；
  - “2”：表示严重的；
  - “3”：表示轻微的；
  - “4”：表示可忽略的。

评估风险影响：发生风险时，有3个因素可能会影响风险所产生的后果：

- 风险的本质：指当风险发生时可能带来的问题。

- 风险的范围：

  - 风险的严重性；
  - 风险的整体分布情况：项目中有多少部分受到影响或有多少客户受到损害。

- 风险的时间：

  - 何时能够感受到风险的影响；
  - 风险的影响会持续多长时间。

- 整体的风险暴露度（RE）：

  - $$
    RE = P * C
    $$

  - P是风险发生的概率，C是风险发生时带来的项目成本

#### 风险评估

一种对风险评估很有用的技术就是定义风险参照水准。对于大多数软件项目来说，有3种典型的风险参照水准

- 成本：成本是否超支
- 进度：进程是否延期
- 性能：性能是否下降

#### 风险控制

**风险控制的目的是辅助项目组建立处理风险的策略**。一个有效的策略必须考虑以下3个问题：

- 风险避免：

  **应对风险的最好办法是主动地避免风险**，即在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生。

- 风险监控：

  项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。

- RMMM计划：

  风险管理策略可以包含在软件项目计划中，或者风险管理步骤也可以组织成一个独立的风险缓解、监控和管理计划（RMMM计划）。RMMM计划将所有风险分析工作文档化，并由项目管理者作为整个项目计划中的一部分来使用。建立了RMMM计划，而且项目己经启动之后，风险缓解及监测步骤也就开始了：

  - 风险缓解：一种问题规避活动。

  - 风险监测：一种项目跟踪活动。

    这种监测活动有3个主要目的：

    - 评估所预测的风险是否真的发生了；
    - 保证正确地实施了各风险的缓解步骤；
    - 收集能够用于今后风险缝隙的信息。

  风险监测的另一个任务就是试图找到“起源”（在整个项目中是哪些风险引起了哪些问题）。
  
  **真题**
  
  ![image-20250428215148928](assets/image-20250428215148928.png)
  
  ![image-20250428215259313](assets/image-20250428215259313.png)
  
  ![image-20250428215309771](assets/image-20250428215309771.png)

![image-20250428215319535](assets/image-20250428215319535.png)

![image-20250428215331690](assets/image-20250428215331690.png)

### 12.软件质量

#### 软件质量特性

讨论软件质量首先要了解软件的质量特性，目前己经有多种软件质量模型来描述软件质量特性，如：

- ISO/IEC 9126 软件质量模型
- Me Call 软件质量模型。

#### ISO/IEC 9126 （考的多）

ISO/IEC 9126软件质量模型由3个层次组成：

1. 第一层：**质量特性**
2. 第二层：**质量子特性**
3. 第三层：**度量指标**

<img src="assets/1685074637082-03033021-2e2d-4fbb-a74f-0afb51fc7495.png" style="zoom: 67%;" />

**质量子特性**的含义：

- 功能性：
  - 适合性：与对规定任务能否提供一组功能以及这组功能是否**适合**有关的软件属性。
  - 准确性：与能够得到**正确**或相符的结果或效果有关的软件属性。
  - 互用性：与其他指定系统进行**交互**操作的能力相关的软件属性。
  - 依从性：使软件**服从**有关的标准、约定、法规及类似规定的软件属性。
  - **安全性：与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性**。
- 可靠性（不包含安全性）：
  - **成熟性**：由软件故障引起失效的频度有关的软件属性。
  - **容错性**：在软件错误或违反指定接口的情况下维持指定的性能水平的能力有关的软件属性。
  - **易恢复性**：故障发生后重新建立性能水平并恢复直接受影响数据的能力，以及为达到此目的所需的时间和努力有关的软件属性。
- 易使用性（不包含易分析性）：
  - 易理解性：与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性。
  - 易学性：与用户为学习其应用（例如操作控制、输入、输出）所付出的努力相关的软件属性。
  - 易操作性：与用户为进行操作和操作控制所付出的努力有关的软件属性。
- 效率：
  - **时间特性**：**与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性**。
  - ** **：与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性。
- 可维护性：
  - 易分析性：与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性。
  - 易改变性：与进行修改、排错或适应环境变换所需努力有关的软件属性。
  - 稳定性：与修改造成未预料效果的风险有关的软件属性。
  - **易测试性：为确认经修改软件所需努力有关的软件属性。**
- 可移植性：
  - 适应性：与软件转移到不同环境时的处理或手段有关的软件属性。
  - 易安装性：与在指定环境下安装软件所需努力有关的软件属性。
  - 一致性：使软件服从与可移植性有关的标准或约定的软件属性。
  - 易替换性：与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性。

简单记忆：

| 功能性                 | 可靠性     |   易用性   | 效率   | **可维护性**   | **可移植性**       |
| ---------------------- | ---------- | :--------: | ------ | -------------- | ------------------ |
| 适合、安全、准、互、依 | 成、容、恢 | 理、学、操 | 时、资 | 分、改、稳、测 | 适应、安装、一、替 |

#### Mc Call 软件质量模型（考的少）

Mc Call也给出了一个三层模型框架：

1. 第一层：质量特性
2. 第二层：评价准则
3. 第三层：度量指标

<img src="assets/16.png">

**真题**

![image-20250428215346635](assets/image-20250428215346635.png)

![image-20250428215404537](assets/image-20250428215404537.png)

![image-20250428215418460](assets/image-20250428215418460.png)

![image-20250428215428148](assets/image-20250428215428148.png)

![image-20250428215443158](assets/image-20250428215443158.png)

### 13.软件评审

通常，把“质量”理解为“用户满意程度”。为了使得用户满意，有以下两个必要条件：

- **设计质量**：设计的规格说明书符合用户的要求。

  设计质量的评审对象：

  ![image-20250428211744662](assets/image-20250428211744662.png)
  
- **程序质量**：程序按照设计规格说明所规定的情况正确执行。程序质量的评审通常是从开发者的角度进行，与开发技术直接相关。

  程序质量的评审对象：

  - 软件结构：
    - 功能结构：
      - 数据结构
      - 功能结构
      - 数据结构和功能结构之间的对应关系
    - 功能的通用性
    - 模块的层次
    - 模块结构：
      - 控制流结构
      - 数据流结构
      - **模块结构与功能结构之间的对应关系**
    - 处理过程的结构
  - 与运行环境的接口：
    - 与硬件的接口
    - 与用户的接口
  - 变更带来的影响

软件的规格说明分为：

- **外部规格说明**：从用户角度来看的规格，包括硬件/软件系统设计、功能设计；设计质量是由外部规格说明决定的
- **内部规格说明**：为了实现外部规格的更详细的规格，即软件模块结构与模块处理过程的设计。内部规格说明是从开发者角度来看的规格说明。程序是由内部规格说明决定的。

**真题**

![image-20250428215503747](assets/image-20250428215503747.png)

![image-20250428215509156](assets/image-20250428215509156.png)

### 14.软件容错技术（14年后没考过）

提高软件质量和可靠性的技术大致可分为两类：

- 避开错误：在开发的过程中不让差错潜入软件的技术；
- 容错技术：对某些无法避开的差错，使其影响减至最小的技术。

实现容错的主要手段是冗余。冗余是指对于实现系统规定功能是多余的那部分资源，包括：

- 硬件
- 软件
- 信息
- 时间

由于加入了这些资源，有可能使系统的可靠性得到较大的提高。通常，冗余技术分为4类：

- **结构冗余**：结构冗余是通常采用的冗余技术，按其工作方法可以分为：

  - 静态冗余：静态冗余通过表决和比较来屏蔽系统中出现的错误。

    - 三模冗余（Triple Module Redundancy，TR）
    - 多模冗余

  - 动态冗余：动态冗余的主要方式是多重模块待机储备。当系统测试到某工作模块出现错误时，就用一个备用模块来顶替它并重新运行。这里包括以下过程：

    - 检测
    - 切换
    - 恢复

    动态冗余有以下两种方式：

    - 热备份系统：每当一个出错模块被其他备用模块顶替后，冗余系统相当于进行了一次重构。

      在热备份系统中，备用模块在待机过程中的失效率为0。

    - 冷备份系统：各备用模块在其待机时可与主模块一同工作，也可不工作。

  - **混合冗余**：兼有静态元余和动态冗余的长处。

- **信息冗余**：指为检测或纠正信息在运算或传输中的错误需外附加的一部分信息。

- **时间冗余**：指以重复执行指令或程序来消除瞬时错误带来的影响。

- **冗余附加技术**：指为实现上述冗余技术所需的资源和技术，包括：程序、指令、数据、存放和调动它们的空间和通道等。在**屏蔽硬件错误的容错技术中**，冗余附加技术包括：

  1. **关键程序和数据的冗余存储及调用**。
  2. 检测、表决、切换、重构、纠错和复算的实现。

  在**屏蔽软件错误的容错系统中**，冗余附加技术的构成包括：

  1. 冗余备份程序的存储及调用。
  2. 实现错误检测和错误恢复的程序。
  3. **实现容错软件所需的固化程序**。

**真题**

![image-20250428215531200](assets/image-20250428215531200.png) 	

### 15.软件工具

#### 软件开发工具

对应于软件开发过程的各种活动，软件开发工具通常有：

- 需求分析工具
- 设计工具
- 编码与排错工具
- 测试工具

#### 软件维护工具

辅助软件维护过程中活动的软件称为软件维护工具，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有：

- **版本控制工具**
- **文档分析工具**
- 开发信息库工具
- **逆向工程工具**
- 再工程工具

#### 软件管理和软件支持工具

软件管理和软件支持工具用来辅助管理人员和软件支持人员的管理活动和支持活动，以确保软件高质量地完成。常用的铺助软件管理和软件支持的工具有：

- 项目管理工具
- 配置管理工具
- 软件评价工具

**真题**

**![image-20250428215550894](assets/image-20250428215550894.png)

杂题

![image-20250428215634159](assets/image-20250428215634159.png)

![image-20250428215644086](assets/image-20250428215644086.png)

![image-20250428215650385](assets/image-20250428215650385.png)

![image-20250428215655966](assets/image-20250428215655966.png)

![image-20250428215701785](assets/image-20250428215701785.png)

![image-20250428215706523](assets/image-20250428215706523.png)

![image-20250428215710635](assets/image-20250428215710635.png)

![image-20250428215715018](assets/image-20250428215715018.png)

![image-20250428215720451](assets/image-20250428215720451.png)







## 第十章 .模块化开发

模块独立

![image-20250429220926619](assets/image-20250429220926619.png)

![image-20250429203233325](assets/image-20250429203233325.png)

#### 耦合

**耦合是模块之间的相对独立性（互相连接的紧密程度）的度量**。

耦合取决于各个模块之间接口的**复杂程度、调用模块的方式以及通过接口的信息类型**等。

<img src="assets/1.png">

- 无直接耦合：指两个模块之间**没有直接**的关系，属于不同模块
- 数据耦合：指两个模块之间有调用关系，传递的是**简单的数据值**
- 标记耦合：指两个模块之间传递的是**数据结构**，**如模块a将学生姓名，学号等放到一个结构体传递给模块b**
- 控制耦合：指一个模块调用另一个模块时，传递的是**控制变量**
- 外部耦合：模块间通过软件之外的环境联结
- 公共耦合：通过一个**公共数据环境**相互作用，**或者说访问相同全局变量或数据结构**
- 内容耦合：当一个模块直接使用另一个模块的**内部数据**，或通过非正常入口转入另一个**模块内部**

**真题**

![image-20250429221341022](assets/image-20250429221341022.png)

![image-20250429221353195](assets/image-20250429221353195.png)

![image-20250429221408412](assets/image-20250429221408412.png)

#### 内聚

考是什么内聚类型

内聚是对一个模块内部各个元素彼此结合的紧密程度的度量。

<img src="assets/2.png">

- 偶然内聚（巧合内聚）：各处理元素之间**没有任何联系**。
- 逻辑内聚：模块内执行若干个**逻辑上**相似的功能。
- 时间内聚：把需要**同时执行的动作组合**在一起。
- 过程内聚：必须按照指定的过程执行。
- 通信内聚：模块内的所有处理元素都在**同一个数据结构**上操作，**如向某个区域数据结构读写数据**。
- 顺序内聚：指一个模块中的各个处理元素都密切相关于同一功能且**必须顺序执行**。
- 功能内聚：最强的内聚，指模块内的所有元素共同作用完成一个功能，**缺一不可**。

总结：耦合性和内聚性是模块独立性的两个定性标准，在将软件系统划分模块时，应尽量做到高内聚、低耦合，提高模块的独立性，低内聚会影响模块间的耦合性。

**真题**

![image-20250429221421437](assets/image-20250429221421437.png)

![image-20250429221516813](assets/image-20250429221516813.png)

![image-20250429221525524](assets/image-20250429221525524.png)

### 系统结构设计原则

1. 分解-协调原则（考的少）
2. 自顶向下的原则（考的少）
3. 信息隐蔽、抽象的原则（考的少）
4. 一致性原则：统一的规范、统一的标准和统一的文件模式。
5. **明确性原则**：功能明确、接口明确、消除多重功能和无用接口、**避免病态连接**、降低接口复杂度。
6. **模块之间的耦合尽可能小，模块的内聚度尽可能高。（高内聚、低耦合）**
7. **模块的扇入系数和扇出系数要合理。（扇入扇出适中）**
8. **模块的规模适当，不是越小越好**。
9. **模块的作用范围应该在其控制范围之内。**

**真题**

![image-20250429221549100](assets/image-20250429221549100.png)

![image-20250429221558269](assets/image-20250429221558269.png)

![image-20250429221607547](assets/image-20250429221607547.png)

### 系统文档（太多，靠蒙）

![image-20250429210942515](assets/image-20250429210942515.png)

**真题**

![image-20250429221631207](assets/image-20250429221631207.png)

![image-20250429221638449](assets/image-20250429221638449.png)

### 数据流图

**关键点记忆** 

**外部实体是当前系统外的，比如图书管理系统中，书就不是外部实体，而读者是；**

**一个加工至少有一个输入和输出；**

**数据流的起点和终点至少有一个是加工**

**结构化分析与数据流图有关**

![image-20250429212719138](assets/image-20250429212719138.png)

![image-20250429212733717](assets/image-20250429212733717.png)

![image-20250429212752969](assets/image-20250429212752969.png)

![image-20250429212802184](assets/image-20250429212802184.png)

![image-20250429212841618](assets/image-20250429212841618.png)

![image-20250429212901166](assets/image-20250429212901166.png)

**真题**

![image-20250429221654806](assets/image-20250429221654806.png)

![image-20250429221725267](assets/image-20250429221725267.png)

![image-20250429221738930](assets/image-20250429221738930.png)

![image-20250429221744554](assets/image-20250429221744554.png)

![image-20250429221749652](assets/image-20250429221749652.png)

### 数据字典

![image-20250429214714659](assets/image-20250429214714659.png)

#### 数据字典的条目

1. **数据流**条目：对DFD中数据流的定义，通常列出该数据流的各组成数据项。
2. **数据项**条目：组成数据流和数据存储的最小元素，是不可再分解的数据单位。
3. **数据存储**条目：对DFD中数据存储的定义。
4. **基本加工**条目：用来说明DFD中（下层）基本加工的处理逻辑（加工逻辑）。

外部实体不包括在数据字典的条目中

#### 加工逻辑的描述

加工逻辑也称为“小说明”。**加工逻辑描述方法有结构化语言、判定表（决策表）和判定树。**

1. 对数据流图的每一个基本加工，**必须有一个基本加工逻辑说明**
2. **基本加工逻辑说明必须描述基本加工如何把输入输出数据流变换为输出数据流的加工规则**
3. **加工逻辑说明必须描述加工实现的策略而不是实现加工的细节**
4. 加工逻辑说明中包含的信息是充足的，完备的，有用的，无冗余的。

**真题**

![image-20250429221808736](assets/image-20250429221808736.png)

![image-20250429221816449](assets/image-20250429221816449.png)

**杂题**

![image-20250429221836488](assets/image-20250429221836488.png)

![image-20250429221846858](assets/image-20250429221846858.png)

![image-20250429221853978](assets/image-20250429221853978.png)

![image-20250429221859301](assets/image-20250429221859301.png)

![image-20250429221904856](assets/image-20250429221904856.png)

![image-20250429221909536](assets/image-20250429221909536.png)

![image-20250429221937132](assets/image-20250429221937132.png)

![image-20250429221943407](assets/image-20250429221943407.png)

![image-20250429221950241](assets/image-20250429221950241.png)

![image-20250429222018926](assets/image-20250429222018926.png)

![image-20250429222038285](assets/image-20250429222038285.png)

![image-20250429222056944](assets/image-20250429222056944.png)

![image-20250429222102460](assets/image-20250429222102460.png)

![image-20250429222107667](assets/image-20250429222107667.png)

![image-20250429222116664](assets/image-20250429222116664.png)

![image-20250429222122364](assets/image-20250429222122364.png)

## 第十一章 知识产权(2-3分)

### 1.著作权

**著作权（也称为版权）：是指作者对其创作的作品享有的人身权和财产权。**

人身权包括：

- 发表权（时限是作者终身及其死亡后50年）
- 署名权（不受时间限制）
- 修改权（不受时间限制）
- 保护作品完整权（不受时间限制）

财产权（**受时间限制**）包括：

- 作品的使用权
- 获得报酬

**真题**

![image-20250430154625330](assets/image-20250430154625330.png)

### 2.**地域性**

![image-20250430154351360](assets/image-20250430154351360.png)

**真题**

![image-20250430154414449](assets/image-20250430154414449.png)

![image-20250430154424651](assets/image-20250430154424651.png)

职务作品开发人员（软件设计师）只享有**<u>署名权（不能被继承）</u>**

### 3.计算机软件著作权（50年）

**计算机软件著作权受到《中华人民共和国著作权法》和《计算机软件保护条例》这两个法律的保护**

![image-20250430160608986](assets/image-20250430160608986.png)

![image-20250430160621528](assets/image-20250430160621528.png)

![image-20250430160632329](assets/image-20250430160632329.png)

![image-20250430160642350](assets/image-20250430160642350.png)

**真题**

![image-20250430160837140](assets/image-20250430160837140.png)

![image-20250430160842713](assets/image-20250430160842713.png)

![image-20250430160848997](assets/image-20250430160848997.png)

### 4.知识产权人确定

**如果是职务软件作品，那开发者只有署名权**

![image-20250430161637574](assets/image-20250430161637574.png)

![image-20250430161642942](assets/image-20250430161642942.png)

![image-20250430161649088](assets/image-20250430161649088.png)**真题**

![image-20250430163014585](assets/image-20250430163014585.png)

![image-20250430163027471](assets/image-20250430163027471.png)

![image-20250430163038085](assets/image-20250430163038085.png)

### 5.委托开发

总结：**如果a委托b开发软件，如果有书面合同就按照书面合同规定的软件作品著作权来归属，如果没有书面合同，就属于受委托方**

![image-20250430162857509](assets/image-20250430162857509.png)

**真题**

![image-20250430164112181](assets/image-20250430164112181.png)

![image-20250430164125966](assets/image-20250430164125966.png)

### 6.侵权判定

**1.如果a公司擅自复制并销售b公司的光盘，c公司在未知的情况下买了a公司的光盘，属于侵权行为，但是如果c公司支付b公司相关费用，就仍可继续使用这些a公司的光盘**

**2.a公司的系统负责人b辞职，a公司将系统的署名更改为他的接替者，侵犯了b的署名权**

**真题**

![image-20250430165552012](assets/image-20250430165552012.png)

![image-20250430165558680](assets/image-20250430165558680.png)

### 7.商业秘密权（无固定期限）

**真题**

![image-20250430172421537](assets/image-20250430172421537.png)



### 8.专利权（10-20年）

1、发明专利权的期限为二十年
2、实用新型专利权的期限为十年
3、外观设计专利权的期限为十五年，均自申请日起计算。

**专利需要公开，专利权需要注册**

![image-20250430172331003](assets/image-20250430172331003.png)

**真题**

![image-20250430173015668](assets/image-20250430173015668.png)

![image-20250430173021699](assets/image-20250430173021699.png)

### 9.商标权（10年 无限续费+）

**同时申请则先使用者先得**

![image-20250430173040357](assets/image-20250430173040357.png)

**真题**

![image-20250430174511255](assets/image-20250430174511255.png)

![image-20250430174527779](assets/image-20250430174527779.png)

![image-20250430174534443](assets/image-20250430174534443.png)

![image-20250430174545734](assets/image-20250430174545734.png)

### 10.杂题

![image-20250430174614865](assets/image-20250430174614865.png)

![image-20250430174624504](assets/image-20250430174624504.png)

![image-20250430174641519](assets/image-20250430174641519.png)

![image-20250430174647958](assets/image-20250430174647958.png)

![image-20250430174747957](assets/image-20250430174747957.png)

![image-20250430174725201](assets/image-20250430174725201.png)

![image-20250430174756243](assets/image-20250430174756243.png)

![image-20250430174802234](assets/image-20250430174802234.png)

![image-20250501193551947](assets/image-20250501193551947.png)

































## 第十二章.数据结构

前提概要

树基本必考，其次线性结构基本必考，最后才是图

![image-20250501200729756](assets/image-20250501200729756.png)



![image-20250501200802045](assets/image-20250501200802045.png)

![image-20250503141923023](assets/image-20250503141923023.png)

![image-20250503141839184](assets/image-20250503141839184.png)

### 1.复杂度

#### 1.1.大O表示法

![image-20250428114545572](assets/image-20250428114545572.png)

#### 1.2.时间复杂度

![image-20250428114627436](assets/image-20250428114627436.png)

#### 1.3、空间复杂度(考的更多)

**定义的数据占用多少空间就是空间复杂度**

![image-20250428114719600](assets/image-20250428114719600.png)

**真题**

![image-20250428114736459](assets/image-20250428114736459.png)

![image-20250428114917933](assets/image-20250428114917933.png)

![image-20250428114759414](assets/image-20250428114759414.png)

![image-20250428135433032](assets/image-20250428135433032.png)

![image-20250428144111911](assets/image-20250428144111911.png)

### 2.线性结构

#### 2.1、定义

![image-20250429103231072](assets/image-20250429103231072.png)

#### 2.2、存储结构

![image-20250429103304255](assets/image-20250429103304255.png)

#### 2.3、顺序存储

没时间记原理了，记住时间复杂度就行，只有顺序表的查找是0（1），其他的包含链式表都是0（n）

**顺序表可以访问任意序号元素，因为有顺序**

**1、插入元素的代码和时间复杂度**

k是插入下标，x是插入的值，n是当前数组长度

![image-20250429103554264](assets/image-20250429103554264.png)

平均复杂度计算原理，在第一个元素插入要挪动n个元素，类推，n+1是因为在n的后面首位也可以插入，相当于push

![image-20250429104401589](assets/image-20250429104401589.png)

- 最好的情况就是直接在顺序表后面插入一个元素，时间复杂度为O(1)
- 最坏的情况是在插入一个元素到原来第一个元素的位置，时间复杂度为O(n)
- 平均复杂度为O(n)

**3、查找元素的代码和时间复杂度**

![image-20250429110955649](assets/image-20250429110955649.png)

**时间复杂度为O(1)，因为这是直接根据数组下边就可以快速查询到对应的元素**

#### 2.4、链式存储

带头结点和不带头节点区别：前者的初始值为null，后者初始值就有值；在链式存储里面next方法就是下一个的意思，

**链式表没有顺序，不能访问任意元素**

**尾节点会指向第一个节点**

**1、插入元素的代码和时间复杂度**

![image-20250501200346213](assets/image-20250501200346213.png)



链表插入不用考虑像数组一样，插入以后还需要将后面的元素向后挪动位置，因为链表的指针域都指向下一个元素的地址

![image-20250501210550051](assets/image-20250501210550051.png)

![image-20250501210954526](assets/image-20250501210954526.png)

**2、删除元素的代码和时间复杂度**

![image-20250501213630722](assets/image-20250501213630722.png)

**3、查找元素的代码和时间复杂度**

![image-20250501213648345](assets/image-20250501213648345.png)



双链表就是比单链表多了一个指针域 指向前一个节点 就可以实现某节点都可以找到自身的上一个节点和下一个节点

**真题**

![image-20250501220653462](assets/image-20250501220653462.png)

**这题需要注意，题目说明了采用尾指针，也就是尾节点的位置已经知道了，可以直接插入到尾结点后面，不用遍历直接插入就行，复杂度为0（1）；删除是要找到删除结点的前面一个结点的位置，我们并不知道尾节点前一个节点的位置，所以需要循环单链表，复杂度为0（n）**

![image-20250501221344260](assets/image-20250501221344260.png)

![image-20250501224031104](assets/image-20250501224031104.png)

![image-20250501224039385](assets/image-20250501224039385.png)



![image-20250501224047955](assets/image-20250501224047955.png)

![image-20250501224054862](assets/image-20250501224054862.png)

![image-20250501224107275](assets/image-20250501224107275.png)

### 3.栈（不常考）

知道特点是后进先出即可

3.1定义

![image-20250501225047237](assets/image-20250501225047237.png)



![image-20250501230933339](assets/image-20250501230933339.png)

**真题**

![image-20250501233636376](assets/image-20250501233636376.png)

![image-20250501233721443](assets/image-20250501233721443.png)

![image-20250501234132696](assets/image-20250501234132696.png)

![image-20250501234937678](assets/image-20250501234937678.png)

![image-20250501235129812](assets/image-20250501235129812.png)

![image-20250501235910067](assets/image-20250501235910067.png)

### 4.队列



![image-20250502134832490](assets/image-20250502134832490.png)



![image-20250502135019187](assets/image-20250502135019187.png)

**真题**

![image-20250502143338250](assets/image-20250502143338250.png)

![image-20250502143322112](assets/image-20250502143322112.png)

![image-20250502143432188](assets/image-20250502143432188.png)

![image-20250502143424280](assets/image-20250502143424280.png)

![image-20250502144009778](assets/image-20250502144009778.png)

![image-20250502145245676](assets/image-20250502145245676.png)

![image-20250502150823384](assets/image-20250502150823384.png)

![image-20250502150830427](assets/image-20250502150830427.png)

![image-20250502150837431](assets/image-20250502150837431.png)

#### 4.1.栈与队列真题

**记住 **

**出栈的元素会立即进入队列**

**出栈的顺序可能不一样，假如一个序列a,b,c 可以abc同时进栈再出栈，也可以a先进栈再出栈，然后bc再进栈再出栈，顺序很灵活**

![image-20250502153232387](assets/image-20250502153232387.png)

![image-20250502153242391](assets/image-20250502153242391.png)

![Snipaste_2025-05-02_15-32-45](assets/Snipaste_2025-05-02_15-32-45.png)

![image-20250502153255419](assets/image-20250502153255419.png)

![image-20250502153300631](assets/image-20250502153300631.png)

![image-20250502153307910](assets/image-20250502153307910.png)

### 5.串（17年后没出过）

#### 5.1定义

![image-20250502154540873](assets/image-20250502154540873.png)

#### **5.2.真题**

![image-20250502154620640](assets/image-20250502154620640.png)

#### 5.3、串的模式匹配和朴素匹配(算法，近些年没考过不看)

### 6.数组

空间地址是不受行或者列的影响，但是当前元素前有多少个元素或者偏移量有影响

![image-20250502160046601](assets/image-20250502160046601.png)

**真题**

![image-20250502162948182](assets/image-20250502162948182.png)

![image-20250502163541318](assets/image-20250502163541318.png)

![image-20250502163637229](assets/image-20250502163637229.png)

### 7.矩阵(没听懂，看公式吧)

这里的题目就举例做就行，如果举得例子有两个答案正确，换一个例子就行，都是按照行的方式，

#### 7.1对称矩阵

![image-20250502165842694](assets/image-20250502165842694.png)

![image-20250502165849914](assets/image-20250502165849914.png)

![image-20250502165855278](assets/image-20250502165855278.png)

#### 7.2三对角矩阵

![image-20250502165914081](assets/image-20250502165914081.png)

#### 7.3稀疏矩阵

![image-20250502165934452](assets/image-20250502165934452.png)

**真题**

![image-20250502171753804](assets/image-20250502171753804.png)

![image-20250502171915835](assets/image-20250502171915835.png)

![image-20250502172629971](assets/image-20250502172629971.png)

![image-20250502173833474](assets/image-20250502173833474.png)

![image-20250502173920979](assets/image-20250502173920979.png)

### 8.树

#### 8.1定义

![image-20250502174203572](assets/image-20250502174203572.png)

![image-20250502183701318](assets/image-20250502183701318.png)

#### 8.2树的性质

![image-20250502175154625](assets/image-20250502175154625.png)



![image-20250502175201972](assets/image-20250502175201972.png)



![image-20250502183446105](assets/image-20250502183446105.png)

**真题**

![image-20250502183955404](assets/image-20250502183955404.png)

![image-20250502185451349](assets/image-20250502185451349.png) 

### 9.二叉树

#### 9.1定义

![image-20250502192302075](assets/image-20250502192302075.png)

![image-20250502192307165](assets/image-20250502192307165.png)

![image-20250503151302169](assets/image-20250503151302169.png)

#### 9.1真题

![image-20250503141328039](assets/image-20250503141328039.png)

![image-20250503141344961](assets/image-20250503141344961.png)

![image-20250503141357621](assets/image-20250503141357621.png)

![image-20250503141403195](assets/image-20250503141403195.png)

![image-20250503141411122](assets/image-20250503141411122.png)

![image-20250503141416686](assets/image-20250503141416686.png)

![image-20250503141422305](assets/image-20250503141422305.png)

#### 9.2存储结构

**1、顺序存储**

![image-20250503143333015](assets/image-20250503143333015.png)

![image-20250503144146235](assets/image-20250503144146235.png)   

**2、链式存储**

![image-20250503152437311](assets/image-20250503152437311.png)

![image-20250503152444988](assets/image-20250503152444988.png)

#### 9.2真题

 ![image-20250503152519512](assets/image-20250503152519512.png)

![image-20250503152527830](assets/image-20250503152527830.png)

![image-20250503152533679](assets/image-20250503152533679.png)

![image-20250503152538801](assets/image-20250503152538801.png)

#### 9.3.遍历

![image-20250503153250653](assets/image-20250503153250653.png)

![image-20250503153738962](assets/image-20250503153738962.png)

![image-20250503153944040](assets/image-20250503153944040.png)

![image-20250503154029324](assets/image-20250503154029324.png)

![image-20250503154053054](assets/image-20250503154053054.png)

#### 9.3通过序列得到树

**注意：想要通过序列得到树，必须包含中序**

先序和中序推断树

![image-20250503161743033](assets/image-20250503161743033.png)



中序和后序

![image-20250503162324697](assets/image-20250503162324697.png)

层次遍历和中序

![image-20250503162511252](assets/image-20250503162511252.png)

#### **9.3真题**

![image-20250503162946305](assets/image-20250503162946305.png)

![image-20250503165140148](assets/image-20250503165140148.png)

![image-20250503165147619](assets/image-20250503165147619.png)

![image-20250503164612436](assets/image-20250503164612436.png)

![image-20250503165157960](assets/image-20250503165157960.png)

#### 9.4平衡二叉树

![image-20250503165331635](assets/image-20250503165331635.png)

#### 9.4二叉排序树

**效率最低的二叉查找树方式是单支树**

![image-20250503170632146](assets/image-20250503170632146.png)

![image-20250503171201480](assets/image-20250503171201480.png)

#### 9.4真题

![image-20250503171342300](assets/image-20250503171342300.png)

![image-20250503171348479](assets/image-20250503171348479.png)

![image-20250503172211711](assets/image-20250503172211711.png)

![image-20250503172156555](assets/image-20250503172156555.png)

![image-20250503172431273](assets/image-20250503172431273.png)

#### 9.5、最优二叉树（哈夫曼树）

**1、定义**

![image-20250503173203639](assets/image-20250503173203639.png)

**2、构造哈夫曼树**

![image-20250503174834228](assets/image-20250503174834228.png)

3、概念

- 权值越大离根节点越近
- 给定的权值节点为叶子节点
- 每个非叶子节点度都为2
- **节点总数等于定的节点的(2n-1)，如给的节点是3那么总节点=3x2-1=5**

4、规范化构造（**对求哈夫曼编码有利**）**这里很重要，看下面例子**

- 从前往后找两个权值最小
- 小左大右加入末尾（若构造完的权值和原本的权值一样，那么构造完的放右边，也就是集合末尾 ）
- 权值相同从前往后，如两个节点为5和6，所以5为左侧树，6为右侧树
- 用时再调用

![image-20250503175242971](assets/image-20250503175242971.png)

![image-20250503175251647](assets/image-20250503175251647.png)

#### 9.5、哈夫曼编码

26个字符可用 2n>=26 n=5位二进制串表示，**如下图必须左0右1**

![image-20250503185806410](assets/image-20250503185806410.png)

![image-20250503182954232](assets/image-20250503182954232.png)

#### 9.5、哈夫曼编码压缩比

![image-20250503185535482](assets/image-20250503185535482.png)

**真题**

![image-20250503213252683](assets/image-20250503213252683.png)

![image-20250503213301640](assets/image-20250503213301640.png)

![image-20250503213315952](assets/image-20250503213315952.png)

![image-20250503190511364](assets/image-20250503190511364.png)

![image-20250503213330639](assets/image-20250503213330639.png)

![image-20250503213347039](assets/image-20250503213347039.png)

![image-20250503213356793](assets/image-20250503213356793.png)

![image-20250503213603998](assets/image-20250503213603998.png)

![image-20250503213820074](assets/image-20250503213820074.png)

![image-20250503214139540](assets/image-20250503214139540.png)

#### 9.6、线索二叉树

**只需要知道任意的二叉树都可以是线索二叉树，只是存储形式和别的二叉树有区别，出题大概率是干扰选项**

**9.6真题**

![image-20250503220119054](assets/image-20250503220119054.png)

![image-20250503220001173](assets/image-20250503220001173.png)

![image-20250503220142138](assets/image-20250503220142138.png)

### 10、图

**无向连通图保证任意两个顶点之间都有访问的路径，而不一定都有边，任意两个定点有边是完全图**

#### 10.1定义

![image-20250504131510158](assets/image-20250504131510158.png)

![image-20250504131606870](assets/image-20250504131606870.png)

![image-20250504131615240](assets/image-20250504131615240.png)

![image-20250504133558722](assets/image-20250504133558722.png)

![image-20250504133616209](assets/image-20250504133616209.png)

![image-20250504133718050](assets/image-20250504133718050.png)

![image-20250504143515264](assets/image-20250504143515264.png)

#### 10.1**真题**

**下面这些画图题目，如果忘记了，可以把图画出来，然后带入数据**

![image-20250504133736302](assets/image-20250504133736302.png)

#### 10.2邻接矩阵

有多少个元素，如有三个节点就是3x3的矩阵

![image-20250504142720280](assets/image-20250504142720280.png)

#### 10.2、邻接表

**邻接表的表节点就是这个节点指向几个别的节点，如下图v0指向v1和v2，所以数量为2，和度不一样，度是指出和指如都算上**

![image-20250504142738302](assets/image-20250504142738302.png)

#### 10.2、稠密图和稀疏图

**记住稠密图适用于边多的图，比如无向完全图，稀疏图适合边少的图**

#### 10.2真题

![image-20250504143258646](assets/image-20250504143258646.png)

![image-20250504143307560](assets/image-20250504143307560.png)

![image-20250504143315687](assets/image-20250504143315687.png)

![image-20250504143324010](assets/image-20250504143324010.png)

#### 10.3图的遍历

知道时间复杂度和大概原理即可

##### **1、深度优先搜索（DFS）**

![image-20250504145158960](assets/image-20250504145158960.png)

**知道时间复杂度即可，不看原理**

![image-20250504145403793](assets/image-20250504145403793.png)

##### **2、广度优先（BFS）**

![image-20250504145838525](assets/image-20250504145838525.png)



#### 10.3真题

![image-20250504150513873](assets/image-20250504150513873.png)

![image-20250504150633722](assets/image-20250504150633722.png)

![image-20250504151823096](assets/image-20250504151823096.png)

![image-20250504151832589](assets/image-20250504151832589.png)

![image-20250504151843340](assets/image-20250504151843340.png)

![image-20250504151853973](assets/image-20250504151853973.png)

#### 10.4、拓扑排序

**记如何计算拓扑排序及几个可能存在就行**

步骤就是找到第一个出度为0的节点，然后将这个节点的边删除，然后继续找从出度为0的节点，一直找到没有0的就完成了，看下面实例

![image-20250504153904868](assets/image-20250504153904868.png)

#### 10.4、真题

![image-20250504154026050](assets/image-20250504154026050.png)

![image-20250504154031489](assets/image-20250504154031489.png)

![image-20250504154038402](assets/image-20250504154038402.png)

![image-20250504154044630](assets/image-20250504154044630.png)

## 第十二章.算法大题

![image-20250504155849665](assets/image-20250504155849665.png)

![image-20250504155917106](assets/image-20250504155917106.png)

![image-20250504155948371](assets/image-20250504155948371.png)

![image-20250504160131529](assets/image-20250504160131529.png)

![image-20250504160149687](assets/image-20250504160149687.png)

![image-20250504160229039](assets/image-20250504160229039.png)

### 1.回溯法

**通过举例可以总结，当处于同一列 或同一斜线就不满足要求，如下**

![image-20250504164015608](assets/image-20250504164015608.png)

n皇后问题

```c
//非递归方法
#include <stdio.h>
#include <math.h>
#include <stdbool.h>

#define N 4 //定义行列数

int q[N + 1]; // 存储皇后的列号
int answer = 0; // 方案数
 //检查传入的行和列是否合法 j=1代表第一行，q[j]就代表的第一列
bool check(int j) {
    for (int i = 1; i < j; i++) {
        // 判断同一列 q[i] == q[j]
        // 判断同一条斜线 |i - j| == |q[i] - q[j]|
        //abs是c语言里面取绝对值的操作如|-3|=3
        if (q[i] == q[j] || abs(q[i] - q[j]) == abs(i-j)) {
            return false;
        }
    }

    return true;
}

void queen() {
    // 初始化
    for (int i = 1; i < N; i++) {
        q[i] = 0;
    }
    int j = 1; // 表示正在拜访第 j 个皇后
    while (j >= 1) {  // 防止回溯越界
         // 让第j个皇后向后一列拜访，由于上面初始化q[i]=0,0+1=1，相当于让第j个皇后默认处在当前行的第一列，并且这里还兼容了当第一个皇后取的列1，第二个皇后取列1时候不满足，所以回溯，此时的q[1]=1,+1也就是q[1]=2,说明是兼容不满足的情况的
        q[j] = q[j] + 1;

        while (q[j] <= N && !check(j)) {  // 不合法后向后移，这里不能用if，因为if只能判断一次，如果移动一次后不符合要求需要继续挪动，并且移动的位置上线是N，也就是列的上线，不然就会超出，超出或者合法循环会结束，判断里面需要是<=不能是<，因为N=4，q[I]=3加1=4，此时这个列4并没有进入check判断时候合法，当找到一个争取的答案数组后，q[4]继续+1，然后就会因为不符合规则或者越界，重置当前行皇后，然后回溯到上一行，上一行的皇后+1，然后不断的循环，直到找出所有答案会停止
            q[j] = q[j] + 1;
        }
        // 如果当前位置合法，一定是合法才会走到这里，因为上面的while循环直到合法或者超出才会结束，只有合法且没有超出才会走到这里，不合法会一直循环里面++到不合法
        if (q[j] <= N) {  
            //j==N说明最后一行也找到了皇后的正确位置，也就是全部皇后摆放完毕，获取到一组正确的解
            if (j == N) {
                // 获得一个解
                answer++;
                printf("循环方案%d: ", answer);

                for (int i=1;i<=N; i++) {
                    printf("%d ", q[i]);
                }
                printf("\n");

            } 
           // 摆放下一个皇后
            else {
                j += 1;
            }
        } 
         //这里说明位置不合法且且判断是不符合，也就是这一行没有找到符合要求的皇后存放列，需要回溯到上一行，让上一行的皇后换位置
        else {
            q[j] = 0; // 重置当前j行皇后的位置
            j -= 1; // 回溯
        }
    }
}

int main() {
    queen();
    return 0;
}
```

```c
//非递归方法
#include <stdio.h>
#include <math.h>
#include <stdbool.h>

#define N 4 //定义行列数

int q[N + 1]; // 存储皇后的列号
int answer = 0; // 方案数

bool check(int j) {
    //这里i<j 就是永远和当前行的上面行比较，如果小于等于就会出现自己和自己比较的情况
    for (int i = 1; i < j; i++) {
        // 判断同一列的值是否相等 q[i] == q[j]
        // 判断同一条斜线 |i - j| == |q[i] - q[j]|
        //abs是c语言里面取绝对值的操作如|-3|=3
        if (q[i] == q[j] || abs(q[i] - q[j]) == abs(i-j)) {
            return false;
        }
    }

    return true;
}


void queen(int j) {
    //这个循环让传递进来的q[1]可以到第一行的每一列
    for (int i=1; i<=N; i++) {
        q[j] = i;
        // 如果符合要求
        if (check(j)) {
            //这里定义的是4x4皇后，N=4，当j等于4
            if (j == N) {
                answer += 1;
                printf("递归方案%d: ", answer);

                for (int k =1; k<=N; k ++) {
                    printf("%d ", q[k]);
                }
                printf("\n");
            } 
            //如果符合要求
            else {
                //递归摆放下一个皇后，如果下一个皇后没有符合要求的，这个方法就执行完毕，会自动消失，这里会自动回溯，假如原先j=1，递归传入的是1，所以是queen（2）,由于2没有任何满足要求的，所以这个函数执行完后，j=1时候，i会继续++，继续循环
                recursiveQueen(j + 1);
            } 
        }
    }
}

int main() {
    queen(1);
    return 0;
}
```

输出 方案1：2 4 1 3

​          方案2：3 1 4 2

#### 1.真题

![image-20250504214912502](assets/image-20250504214912502.png)

![image-20250504215458119](assets/image-20250504215458119.png)

### 2.分治法

![image-20250505150902141](assets/image-20250505150902141.png)

#### 2.1分治法应用

**归并排序**

![image-20250505161122350](assets/image-20250505161122350.png)

![image-20250505161651131](assets/image-20250505161651131.png)

**如数组A=[3,1,5,7,2] 输出结果为[1,2,3,5,7]**

**真题1  14年**

![image-20250505180815720](assets/image-20250505180815720.png)

真题2  17年

![image-20250505181219980](assets/image-20250505181219980.png)

**问题3 比较次数**

![image-20250505181420730](assets/image-20250505181420730.png)

**真题3 2020年（很难）**

1.直接插入排序就是将一组无序数组变成顺序的，而直接插入排序最好的时间复杂度前提是这个无需数组、相对有序，也就是有部分排序是对的；

2.步长序列：举例有个集合15，9，7，8，20，-1，4，假设n=7，那么delta1=7/2=3；delta2=3/2=1，所以存在两个序列，首先按照delta1=3进行排序，得到如下图的15到8，8到4，9到20，7到-1这四个步长为3的元素，第一次直接插入排序为15和8，和4进行排序，从小到大切换顺序为4，9，7，8，20，-1，15，然后按照9和20排序为4，9，7，8，20，-1，15，然后按照7和-1排序变为4，9，-1，8，20，7，15，然后用delta2=1进行排序，也就是一个元素一组，排序变为-1，4，7，，8，9，15，20，**之所以这样是因为直接插入排序在相对有序的的集合进行排序时间复杂度最小**，而步长排序可以让集合在进行直接排序前变得基本有序

![image-20250505183622743](assets/image-20250505183622743.png)

![image-20250505194131557](assets/image-20250505194131557.png)

![image-20250505193906819](assets/image-20250505193906819.png)

### 3.动态规划法(考最多)

![image-20250505195442550](assets/image-20250505195442550.png)

![image-20250505210130667](assets/image-20250505210130667.png)

0-1背包问题，实现当你指定容量，可以获取到你指定容量的最大价值也就是最优解。代码很巧妙的记录了前面的子最优解，将选i个物品和不选第i个物品的代码联系起来了

![image-20250505222819006](assets/image-20250505222819006.png)

代码实现

```c

        int N = 4;  // 物品数量
        int W = 5;  // 背包容量
        int[] v = {0, 2, 4, 5, 6};   // 物品价值数组
        int[] w = {0, 1, 2, 3, 4};   // 物品重量数组
        int f[N + 1][W + 1] = {}; // 子问题解数组

        for (int i = 1; i <= N; i++) {     // 物品编号
            for (int j = 1; j <= W; j++) { // 背包容量
                if (j >= w[i]) { // 选择当前物品
                    // (上一个物品的最优解) 比较 (当前物品价值+剩余容量在上一个物品的最优解)
                    f[i][j] = Math.max(f[i - 1][j], v[i] + f[i - 1][j - w[i]]);
                } else {		 // 不选择当前物品
                    // 直接使用上一个物品的最优解
                    f[i][j] = f[i - 1][j];
                }
            }
        }

        System.out.println("最优解:" + f[N][W]);

        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= W; j++) {
                System.out.printf("%d", f[i][j]);
                System.out.print(" ");
            }
            System.out.println();
        }


```

//输出 ：9

## 8.设计模式

**需要掌握 意图，适用性，和图下面的讲解即可完成上午题，需要会看图，代码都是大致根据图就写出来的，这是下午题要记住的**



**听不懂的话要看接口和抽象的简单相关知识**

java基础

![image-20250411175256758](assets/image-20250411175256758.png)

![image-20250411162930442](assets/image-20250411162930442.png)

![image-20250411163115930](assets/image-20250411163115930.png)

![image-20250411163121181](assets/image-20250411163121181.png)

### 1.1，简单工厂模式

![image-20250411182514436](assets/image-20250411182514436.png)

```java
class Factory {
    
    public void createProduct(Product product) {
        product.info();
    }
}

abstract class Product {
    public abstract void info();
}

class ProductA extends Product {
    @Override  //重写这个方法的注释，提示使用者，没有实际功能
    public void info() {
        System.out.println("产品信息：A");
    }
}

class ProductB extends Product {
    @Override
    public void info() {
        System.out.println("产品信息：B");
    }
}
public class SimpleFactory {
    public static void main(String[] args) {
        Factory factory = new Factory();
        Product productA = new ProductA();
        Product productB = new ProductB();
        factory.createProduct(productA);
        factory.createProduct(productB);
    }
}

// 输出结果为：
// 产品信息：A
// 产品信息：B

```

### 2.1、工厂方法模式（Factory Method）

![image-20250415201929329](assets/image-20250415201929329.png)

![image-20250415201938367](assets/image-20250415201938367.png)

![image-20250415201956359](assets/image-20250415201956359.png)

![image-20250415202011996](assets/image-20250415202011996.png)

```java
interface Product {
    void info();
}

class ProductA implements Product {
    @Override
    public void info() {
        System.out.println("产品信息：A");
    }
}

class ProductB implements Product {
    @Override
    public void info() {
        System.out.println("产品信息：B");
    }
}

interface Factory {
    Product createProduct();
}

class FactoryA implements Factory {
    @Override
    public Product createProduct() {
        return new ProductA();
    }
}

class FactoryB implements Factory {
    @Override
    public Product createProduct() {
        return new ProductB();
    }
}

```

```java
public class SimpleFactory {
    public static void main(String[] args) {
        Factory factoryA = new FactoryA();
        Product productA = factoryA.createProduct();
        productA.info();

        Factory factoryB = new FactoryB();
        Product productB = factoryB.createProduct();
        productB.info();
    }
}

```

### 2.2、抽象工厂模式（Abstract Factory）

1.定义

比如 一个顾客要吃猪肉清汤饺子，而店里面有食物类别饺子和面，汤底类型麻辣和清汤，这些任意组合的过程大概就是抽象工厂

![image-20250415202127509](assets/image-20250415202127509.png)

![image-20250415202138761](assets/image-20250415202138761.png)

```java
interface Factory {
    // 手机
    ProductA createProductA();
    // 平板
    ProductB createProductB();
}

// 苹果工厂
class Factory1 implements Factory {
    // 苹果手机
    @Override
    public ProductA createProductA() {
        return new ProductA1();
    }
    // 苹果平板
    @Override
    public ProductB createProductB() {
        return new ProductB1();
    }
}

// 小米工厂
class Factory2 implements Factory {
    // 小米手机
    @Override
    public ProductA createProductA() {
        return new ProductA2();
    }
    // 小米平板
    @Override
    public ProductB createProductB() {
        return new ProductB2();
    }
}

// 手机
interface ProductA {
    void info();
}

class ProductA1 implements ProductA {
    @Override
    public void info() {
        System.out.println("产品信息：A1");
    }
}

class ProductA2 implements ProductA {
    @Override
    public void info() {
        System.out.println("产品信息：A2");
    }
}

// 平板
interface ProductB {
    void info();
}

class ProductB1 implements ProductB {
    @Override
    public void info() {
        System.out.println("产品信息：B1");
    }
}

class ProductB2 implements ProductB {
    @Override
    public void info() {
        System.out.println("产品信息：B2");
    }
}

```

```java
public class SimpleFactory {
    public static void main(String[] args) {
        Factory factory1 = new Factory1();
        Factory factory2 = new Factory2();

        ProductA productA1 = factory1.createProductA();
        ProductB productB1 = factory1.createProductB();
        productA1.info();
        productB1.info();

        ProductA productA2 = factory2.createProductA();
        ProductB productB2 = factory2.createProductB();
        productA2.info();
        productB2.info();
    }
}

```

真题1

![image-20250415201814827](assets/image-20250415201814827.png)

### 2.3、生成器模式（Builder）

1.定义

**根据套餐创造具体的产品，涉及到套餐这方面的概念，就用builder**

![image-20250415210055326](assets/image-20250415210055326.png)



解释代码

在 Java 中，语句 `List<String> parts = new ArrayList<String>();` 的作用是 **创建一个可动态调整大小、类型安全的字符串列表**。以下是详细解析：

- **`List<String>`**
  - 声明一个名为 `parts` 的变量，类型为 `List<String>`（列表接口，泛型指定为 `String`）。
  - 使用接口（`List`）而非具体实现类（如 `ArrayList`）是良好实践，便于后续灵活更换实现（例如改为 `LinkedList`）。
- **`new ArrayList<String>()`**
  - 实例化一个 `ArrayList` 对象，它是 `List` 接口的 **基于动态数组的实现**。
  - `<String>` 确保类型安全，该列表只能存储字符串。

**代码实现**

![image-20250415205550845](assets/image-20250415205550845.png)

![image-20250415205615022](assets/image-20250415205615022.png)

![image-20250415205703734](assets/image-20250415205703734.png)

![image-20250415205752888](assets/image-20250415205752888.png)

![image-20250415210215414](assets/image-20250415210215414.png)

**真题1**

![image-20250415211047967](assets/image-20250415211047967.png)

真题2

![image-20250415212131708](assets/image-20250415212131708.png)

![image-20250415212150154](assets/image-20250415212150154.png)

### 2.4、原型模式（Prototype）

类似于一副画，克隆出另外一副一模一样的

1.定义

![image-20250415212431918](assets/image-20250415212431918.png)

![image-20250415212441652](assets/image-20250415212441652.png)

```java
interface Prototype {
    Object clone();
}

class Product implements Prototype {
    //私有变量
    private int id;
    private String name;

    public Product() {
    }

    public Product(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return id + " " + name;
    }

    @Override  
    //这个方法就是为了返回一个克隆的对象
    public Object clone() {
        Product obj = new Product();
        obj.id = this.id;
        obj.name = this.name;
        return obj;
    }
}

```

```java
public class Test01 {
    public static void main(String[] args) {
        Product a = new Product(1, "A");
        //这里(Product)的意思就是类型转换为Product，因为貌似这里被当成了Object
        Product clone = (Product) a.clone();
        System.out.println(a.toString);  //输出：1 "A"
        System.out.println(clone.toString);//输出：1 "A"
    }
}

```

### 2.5、单例模式（Singleton）上午不考

![image-20250415214231855](assets/image-20250415214231855.png)

代码

![image-20250415215102042](assets/image-20250415215102042.png)

![image-20250415215313708](assets/image-20250415215313708.png)

真题1

![image-20250415215441809](assets/image-20250415215441809.png)

真题2

![image-20250415215636990](assets/image-20250415215636990.png)

真题3

![image-20250415215644946](assets/image-20250415215644946.png)



### 三、结构性设计模式(编译看左边，运行看右边)

**考察频率**

![image-20250416142808325](assets/image-20250416142808325.png)

![image-20250416143147593](assets/image-20250416143147593.png)

模式	意图
适配器模式	将一个类的接口转换成客户希望的另一个接口
桥接模式	将抽象与其实现部分分类，使他们都可以独立的变化
组合模式	将对象组合成树形模式以表示 部分与整体
装饰模式	动态地给一个对象添加额外的职责
外观模式	为子系统中的一组接口提供一个一致的接口，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
享元模式	运用共享技术有效地支持大量细粒度的对象
代理模式	为其他对象提供一种代理以控制对这个对象的访问

### 3.1、适配器模式（Adapter）

#### 1、定义

![image-20250416150146820](assets/image-20250416150146820.png)

![image-20250416150217556](assets/image-20250416150217556.png)

![image-20250416150250507](assets/image-20250416150250507.png)

代码演示 

客户使用Lighting接口的手机，适配器继承该手机的充电方式并将其转为TypeC

```java
// 客户使用的手机
class Lighting {
    public void Request() {
        System.out.println("Lighting数据线");
    }
}

// 适配器
class Adapter extends Lighting {
    //定义私有化的TypeC实例
    //编译看左边，运行看右边
    private TypeC typeC = new TypeC();

    @Override
    public void Request() {
        typeC.SpecificRequest();
    }
}

// 数据线
class TypeC {
    public void SpecificRequest() {
        System.out.println("TypeC数据线");
    }
}

```

```java
public class Test01 {
    public static void main(String[] args) {
        Lighting lighting = new Adapter();
        lighting.Request();
    }
}

```

### 3.2、桥接模式（Bridge）

注意图的箭头指向

![image-20250416155528028](assets/image-20250416155528028.png)

![image-20250416155457860](assets/image-20250416155457860.png)

![image-20250416155545984](assets/image-20250416155545984.png)

![image-20250416155558628](assets/image-20250416155558628.png)

![image-20250416155607747](assets/image-20250416155607747.png)

抽象部分调用实现部分，就是不断的抽象和接口套娃

```java
//定义了一个抽象类和一个接口，本质就是让不同继承这个抽象类的类去获取履行这个接口的不同类内的方法或数据，代码逻辑有点绕
public class Test01 {
    public static void main(String[] args) {
        Product productA = new ProductA();
        Product productB = new ProductA();

        Color red = new Red();
        Color blue = new Blue();

        productA.setName("裙子");
        productA.setColor(red);
        productA.Operation();

        productB.setName("裤子");
        productB.setColor(blue);
        productB.Operation();
    }

}

// 抽象
abstract class Product {
    //方便下面打印信息
    private String name;
    //维护一个指向Implementor类型对象的指针
    protected Color color;
    //方便下面打印信息的方法
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setColor(Color color) {
        //给上面的color类赋值为红色类还是蓝色类
        this.color = color;
    }
    //上图中Abstraction中的方法Operation()
    public abstract void Operation();
}

// 抽象部分
class ProductA extends Product {

    @Override
    public void Operation() {
        //由于继承了Product抽象类所以可以直接使用这个类里面的属性
        color.OperationImp(this.getName());
    }
}

// 接口
interface Color {
    public void OperationImp(String name);
}

// 实现部分
class Red implements Color {

    @Override
    public void OperationImp(String name) {
        System.out.println(name + ":红色");
    }
}

// 实现部分
class Blue implements Color {

    @Override
    public void OperationImp(String name) {
        System.out.println(name + ":蓝色");
    }
}

```

输出

```java
裙子:红色
裤子:蓝色
```

上午真题1

![image-20250416165202921](assets/image-20250416165202921.png)

真题2

![image-20250416165818258](assets/image-20250416165818258.png)

### 3.3、组合模式（Composite）(考过多次大题)

#### 1、定义

![image-20250416194756517](assets/image-20250416194756517.png)

![image-20250416210200537](assets/image-20250416210200537.png)

![image-20250416205654094](assets/image-20250416205654094.png)

下面实现功能如上图，创建一个文件夹，可以遍历这个出这个文件夹中所有的文件及文件夹及子文件，子文件夹名称打印出来，包含自身，文件内没有文件夹

```java
//抽象组合组件
abstract class AbstractFile {
    protected String name;

    public void printName() {
        System.out.println(name);
    }

    public abstract boolean add(AbstractFile abstractFile);
    public abstract boolean remove(AbstractFile abstractFile);
    public abstract List<AbstractFile> getChildren();
}
//继承抽象组合组件的文件夹类
class Folder extends AbstractFile {
    //List<AbstractFile> ：声明一个为AbstractFile类的集合，尖括号是泛型的意思，之所以用这个类型是因为这个List里面需要同时包含Folder和File这两种类 ；new ArrayList<>也可以写成new ArrayList<AbstractFile>
    private List<AbstractFile> childrenList = new ArrayList<>();

    public Folder(String name) {
        this.name = name;
    }

    @Override
    //这里之所以写AbstractFile，因为这里可能传递File也可能是Folder，而AbstractFile包含这两种情况
    public boolean add(AbstractFile abstractFile) {
        //childrenList.add(abstractFile)操作存在返回值true，这是java的组合自带的语法糖
        return childrenList.add(abstractFile);
    }

    @Override
    public boolean remove(AbstractFile abstractFile) {
        return childrenList.remove(abstractFile);
    }

    @Override
    public List<AbstractFile> getChildren() {
        return childrenList;
    }
}

class File extends AbstractFile {
    public File(String name) {
        this.name = name;
    }

    @Override
    //因为文件不能添加，但是又需要实现继承的抽象类的方法，就返回个false即可
    public boolean add(AbstractFile abstractFile) {
        return false;
    }

    @Override
    //因为文件不能添加，但是又需要实现继承的抽象类的方法，就返回个false即可
    public boolean remove(AbstractFile abstractFile) {
        return false;
    }

    @Override
    public List<AbstractFile> getChildren() {
        return null;
    }
}

```

```java
//调用类
public class Test01 {
    public static void main(String[] args) {
        AbstractFile root = new Folder("root");

        AbstractFile foldA = new Folder("FoldA");
        AbstractFile fileA1 = new File("fileA1");
        AbstractFile fileB = new File("fileB1");
        root.add(fileB); //根目录添加文件
        root.add(foldA); //根目录添加文件夹
        foldA.add(fileA1);//folderA里面添加文件

        print(root);//循环打印的时候需要吧foldeA集合里面的元素也打印出来
    }

    static void print(AbstractFile abstractFile) {
        // 打印当前文件夹/文件
        abstractFile.printName();

        // 获取子文件夹/文件
        List<AbstractFile> children = abstractFile.getChildren();
        if (children == null) return;//这里是递归的结束，当传进来的children为空就说明递归结束，不为空就要进入递归，此时也就说明传进来的是文件，因为文件不需要遍历
        //for(对象类型 对象名 ： 遍历对象)
        for (AbstractFile file : children) {
            print(file);//这里是递归
        }
    }
}

```

效果，依次运行出根目录root包含自己的所有文件夹和文件的名称

![image-20250416205421467](assets/image-20250416205421467.png)

真题1

![image-20250416210305869](assets/image-20250416210305869.png)

真题2

![image-20250416210506897](assets/image-20250416210506897.png)

### 3.4、装饰模式（Decorator）

相当于现有功能不足的时候，需要补充一些别的功能

#### 1、定义

![image-20250416212016107](assets/image-20250416212016107.png)

![image-20250416212029360](assets/image-20250416212029360.png)

代码实现 非常巧妙的

```java
abstract class Decorator extends Person {
    //指针指向Person
    protected Person person;
}

// 装饰器A
class DecoratorA extends Decorator {
    //这里相当于实例化DecoratorA时候就需要向DecoratorA里面传递一个类，记住！
    public DecoratorA(Person person) {
        this.person = person;
    }

    @Override
    //这里需要实现operation，来自爷爷，因为爷爷是抽象类，所以父亲需要实现爷爷的方法，但是父亲也是抽象类，以此类推到孙子需要实现爷爷的方法
    public void operation() {
        person.operation();  // 原本的职责
        System.out.println("装饰器A新职责：写作业");//这是添加的新职责，就是除了原有职责外完成别的事情
    }
}

class DecoratorB extends Decorator {
    
    public DecoratorB(Person person) {
        this.person = person;
    }

    @Override
    public void operation() {
        person.operation();  // 原本的职责
        System.out.println("装饰器B新职责：做家务");
    }
}
 
abstract class Person {
    protected String name;
    
    public abstract void operation(); // 职责
}

class Student extends Person {

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void operation() {
        System.out.println(name + "的职责:学习");
    }
}

```

```java
//不明白就看输出 zhangsan的输出在不断增加东西
public class Test01 {
    public static void main(String[] args) {
        Person zhangsan = new Student("zhangsan");
        zhangsan.operation(); //输出 zhangsan的职责：学习

        System.out.println("================");
        //父类名 对象名 = new 子类名()  因为抽象类不能实例化，只能实例他的子类
        //这一步非常秒，相当于把添加了新的职责的zhangsan赋给zhangsan，让现在的张三具有更多新的职责，这个zhangsan其实就是上面的Person zhangsan这个实例化的类！不断的将添加了新职责的类赋值给新的类，将最终类在赋给初始类，就完成了初始类添加了多个职责的效果
        zhangsan = new DecoratorA(zhangsan)
        zhangsan.operation();//输出zhangsan的职责：学习，和新职责写作业
        zhangsan = new DecoratorB(zhangsan);
        zhangsan.operation();//输出zhangsan的职责：学习 装饰器B新职责:做家务 装饰器A新职责:写作业
    }
}


```

还有一种链式调用写法，虽然名字不一样，但是原理是一样的

![image-20250416215532982](assets/image-20250416215532982.png)

![image-20250416213644289](assets/image-20250416213644289.png)



上午题

![image-20250416215621202](assets/image-20250416215621202.png)

### 3.5、外观模式（Facade）

就是类似于在主系统中，有许多子系统，比如软考系统，有登录，注册都算子系统，通过主页面跳转过去

![image-20250417200638096](assets/image-20250417200638096.png)

![image-20250417200702613](assets/image-20250417200702613.png)

代码

```java
import java.util.Scanner;

/**
 */
public class FacadePattern {
    public static void main(String[] args) {
        //当实例化的时候，类里面的同名也会被注册
        Facade facade = new Facade();

        facade.methodA();
        facade.methodB();
        facade.methodC();
    }
}

class Facade{
    SubSystemOne subSystemOne;
    SubSystemTwo subSystemTwo;
    SubSystemThree subSystemThree;
    //构造方法必须和类同名 主要用于在创建对象时 初始化对象的属性 或 执行必要的准备工作 
    //在构造方法中初始化子系统
    public Facade(){
        subSystemOne = new SubSystemOne();
        subSystemTwo = new SubSystemTwo();
        subSystemThree = new SubSystemThree();
    }

    public void methodA(){
        subSystemOne.methodOne();
    }

    public void methodB(){
        subSystemTwo.methodTwo();
    }

    public void methodC(){
        subSystemThree.methodThree();
    }
}

class SubSystemOne{
    public void methodOne(){
        System.out.println("执行子系统一的功能~");
    }
}

class SubSystemTwo{
    public void methodTwo(){
        System.out.println("执行子系统二的功能~");
    }
}

class SubSystemThree{
    public void methodThree(){
        System.out.println("执行子系统三的功能~");
    }
}
```

上午真题1

![image-20250417201733385](assets/image-20250417201733385.png)

真题2

![image-20250417202343282](assets/image-20250417202343282.png)



可以这样理解，有个很抠门的人带来一副五子棋，这副棋只有黑白各一颗棋子、一个用于记录的本本和棋盘，每下一次拿本本记录棋子的颜色和下的位置，通过本本的记录判断局势

### 3.6. Flyweight（享元）

**享元模式就是，判断你有没有这个类的实例，如果没有就创建实例，然后后面做任何事情都是用这个实例去做，如果有这个实例就继续用这个实例去做，总之不会创造第二个相同类的实例**，也就是共享实例

1）意图

运用共享技术有效地支持大量细粒度的对象。

2）结构

​		<img src="assets/image-20230415145022868.png" style="zoom:67%;" />

其中：

- Flyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态。

- ConcreteFlyweight 实现Flyweight接口，并为内部状态（如果有）增加存储空间。

- ConcreteFlyweight 对象必须是可共享的。它所存储的状态必须是内部的，即它必须独立于 ConcreteFlyweight 对象的场景。

- 并非所有的 Flyweight 子类都需要被共享。Flyweight 接口使共享成为可能，但它并不强制共享。在 Flyweight 对象结构的某些层次，UnsharedConcreteFlyweight 对象通常将ConcreteFlyweight 对象作为子结点。

- FlyweightFactory 创建并管理Flyweight对象；确保合理地共享Flyweight,当用户请求一个Flyweight时，FlyweightFactory 对象提供一个已创建的实例或者在不存在时创建个实例。

- Client 维持一个对 Flyweight 的引用；计算或存储一个或多个 Flyweight 的外部状态。

  3）适用性

  Flyweight模式适用于：

  - 一个应用程序使用了大量的对象。
  - 完全由于使用大量的对象，造成很大的存储开销。
  - 对象的大多数状态都可变为外部状态。
  - 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
  - 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，所以对于概念上明显有别的对象，标识测试将返回真值。

```java
/**
 * 享元模式 案例1
 */

public class FlyweightPattern {
    public static void main(String[] args) {
        PieceFactory factory = new PieceFactory();
        //这个对象无论实例化多少次都是同一个类，这同一个类在不停调用draw方法
        //就是声明的两个类 黑棋和白棋，在不断的调用draw方法在不同位置去下棋的过程
        Piece whitePiece1 = factory.getPiece(0);
        whitePiece1.draw(66,87);
        System.out.println(whitePiece1);

        Piece blackPiece1 = factory.getPiece(1);
        blackPiece1.draw(20,11);
        System.out.println(blackPiece1);

        Piece whitePiece2 = factory.getPiece(0);
        whitePiece1.draw(26, 54);
        System.out.println(whitePiece2);

        Piece blackPiece2 = factory.getPiece(1);
        blackPiece2.draw(12, 34);
        System.out.println(blackPiece2);
    }
}

class PieceFactory{
    //这里定义的是一个Piece类型的数组
    private Piece[] pieces = {new WhitePiece(),new BlackPiece()};

    public Piece getPiece(int key){
        if (key == 0) return pieces[0];
        else return pieces[1];
    }
}

abstract class Piece{
    protected String color;

    public abstract void draw(int x,int y);
}

class WhitePiece extends Piece{
    public WhitePiece(){
        this.color = "white";
    }

    @Override
    public void draw(int x, int y) {
        System.out.println("draw a color: "+color + " piece x: " + x + " y:　" + y);
    }
}

class BlackPiece extends Piece{
    public BlackPiece(){
        this.color = "black";
    }

    @Override
    public void draw(int x, int y) {
        System.out.println("draw a color: " + color + " piece x: " + x + " y:　" + y);
    }
}
```

```java
/**
 * 享元模式 案例2 创建多个圆，没创建过的就新建，存在的实例就接着使用
 */

public class FlyweightPattern {
    public static void main(String[] args) {
        ShapeFactory factory = new ShapeFactory();
        //公共的创造随机数类
        Random random = new Random();
        //一个字符串数组，这是java的写法
        String[] colors = {"red","blue","green","whilte","black"};

        for (int i = 1; i <= 10; i++) {
            //取0-4的随机数
            int x = random.nextInt(colors.length);
            Shape shape = factory.getShape(colors[x]);
            System.out.print("第" + i + "个圆：");
            shape.draw(random.nextInt(2022),random.nextInt(528));
        }
    }

}

class ShapeFactory{
    //Map<String,Shape>是java中的一个不需要定义的 左边为键右边为值，new HashMap<>是java中自带的声明的方式，就记住是个键值对数组就行了
    private Map<String,Shape> map = new HashMap<>();

    public Shape getShape(String key){
        //这是HashMap自带的方式，判断这个键是否存在，不存在就调用自带的方式创建这个到map里面，最后return返回这个键的值
        if (!map.containsKey(key)) {
            map.put(key, new Circle(key));
            System.out.println("create color: " + key + " circle");
        }
        return map.get(key);
    }
}

abstract class Shape {
    protected String color;

    public abstract void draw(int x, int y);
}

class Circle extends Shape {

    public Circle(String color){
        this.color = color;
    }

    @Override
    public void draw(int x, int y) {
        System.out.println("draw a color: " + color + " circle x："+ x + " y：" + y);
    }
}
```

输出

![image-20250417211349856](assets/image-20250417211349856.png)



**上午真题1**

![image-20250417211643038](assets/image-20250417211643038.png)

### 3.7. Proxy(代理)

代理本质上就是中介，当你买房的时候中介会帮你办好所有手续，你只需要付钱即可

1）意图

为其他对象提供一种代理以控制对这个对象的访问。

2）结构

![](assets/image-20230415154708049.png)

3）适用性 (了解)
Poxy模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见情况有：

- 远程代理(Remote Proxy)为一个对象在不同地址空间提供局部代表。
- 虚代理(Virtual Proxy)根据需要创建开销很大的对象。
- 保护代理(Protection Proxy)控制对原始对象的访问，用于对象应该有不同的访问权限的时候。
- 智能引用(Smart Reference)取代了简单的指针，它在访问对象时执行一些附加操作。

```java
/**
 * 代理模式
 */
 //调用
public class ProxyPattern {
    public static void main(String[] args) {
        //正常RealSubject类只能完成付钱操作，但是将他传递给中间代理，代理可以帮他完成操作的同时，进行这个类本来需要进行的操作，比如买房甲方只用付钱，而中介会把所有手续帮你办好只等你付钱
        RealSubject realSubject = new RealSubject();
        Proxy proxy = new Proxy(realSubject);

        proxy.buy();
    }
}

interface Subject{
    void buy();
}
//代理
class Proxy implements Subject{
    //定义一个受保护的属性接受需要引用的实例
    protected RealSubject realSubject;
    //将传入的实例赋值
    public Proxy(RealSubject realSubject){
        this.realSubject = realSubject;
    }

    @Override
    //这里代理即会完成一些操作也会完成代理的甲方的操作
    public void buy() {
        System.out.println("办理购买前的手续~");
        realSubject.buy(); // 付钱
        System.out.println("办理购买后的手续~");
    }
}

class RealSubject implements Subject{

    @Override
    public void buy() {
        System.out.println("付钱~");
    }
}
```

输出

![image-20250417213326748](assets/image-20250417213326748.png)

上午真题1

![image-20250417213627937](assets/image-20250417213627937.png)

### 行为设计模式（11种）

**下午题考查频率至2022年，下面画横线的是考过的**

![image-20250417213943475](assets/image-20250417213943475.png)

### 1. Chain of Responsibility（责任链）

比如一个学生请假，如果请假三天可以找辅导员，超过三天小于7天要找院长，超过7天要找校长，最后超过三十天返回null

1）意图

**使多个对象都有机会处理请求**，从而避免请求的发送者和接收者之间的耦合关系。**将这些对象连成一条链**，并沿着这条链传递该请求，直到有一个对象处理它为止。

2）结构

​						<img src="assets/image-20230415171040969.png" style="zoom: 67%;" />

其中：

- Handler定义一个处理请求的接口；（可选）实现后继链。
- ConcreteHandler处理它所负责的请求；可访问它的后继者；如果可处理该请求，就处理它，否则将该请求转发给后继者。
- Client向链上的具体处理者(ConcreteHandler)对象提交请求。

```java
/**
 * 责任链模式
 */
public class ChainOfResponsibilityPattern {
    public static void main(String[] args) {
        //首先实例化辅导员，院长，和校长三个类
        Handler counsellor = new Counsellor();
        Handler dean = new Dean();
        Handler headmaster= new Headmaster();
        //将院长实例传入辅导员，这样当辅导员无法审批就能给院长审批
        counsellor.setNext(dean);
        //再将校长传给院长，如果院长无法审批，这个审批就会传递到校长审批，如果校长也无法审批就返回null
        dean.setNext(headmaster);
       //给辅导员实例传入需要审批的天数25
        counsellor.HandRequest(25);
    }

}

abstract class Handler{
    //这里是成员变量，实际也是定义了一个为这个类的实例变量
    protected Handler next;

    public void setNext(Handler next){
        this.next =next;
    }

    public abstract void HandRequest(int request);
}

class Counsellor extends Handler{

    @Override
    public void HandRequest(int request) {
        if (request <= 7){
            System.out.println("辅导员审批通过~");
        }else {
            if (next != null){
                next.HandRequest(request);
            }else {
                System.out.println("无法审批");
            }
        }
    }
}

class Dean extends Handler{

    @Override
    public void HandRequest(int request) {
        if (request <= 15){
            System.out.println("院长审批通过~");
        }else {
            if (next != null){
                next.HandRequest(request);
            }else {
                System.out.println("无法审批");
            }
        }
    }
}

class Headmaster extends Handler{

    @Override
    public void HandRequest(int request) {
        if (request <= 30){
            System.out.println("校长审批通过~");
        }else {
            if (next != null){
                next.HandRequest(request);
            }else {
                System.out.println("无法审批");
            }
        }
    }
}
```

3）适用性

Chain of Responsibility 模式适用于以下条件：

- 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。
- 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。
- 可处理一个请求的对象集合应被动态指定。

### 2.  Command（命令）（下午考过）

1）意图

将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对**请求排队**或记录**请求日志**，以及支持可**撤销**的操作。

2）结构

![](assets/image-20230415173855870.png)

其中：

- Command声明执行操作的接口。
- ConcreteCommand 将一个接收者对象绑定于一个动作：调用接收者相应的操作，以实现Execute。
- Client 创建一个具体命令对象并设定它的接收者。
- Invoker 要求该命令执行这个请求。
- Receiver 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。

```java
/**
 * 命令模式
 */
public class CommandPattern {
    public static void main(String[] args) {
        Tv tv = new Tv(); // 接收者 对象 电视机

        Command onCommand = new OnCommand(tv); // 命令对象 开机命令
        Command offCommand = new OnCommand(tv); // 命令对象 关机命令

        Invoker invoker = new Invoker(); //请求者
        invoker.setCommand(onCommand); // 给请求者设置 开机 命令
        invoker.call(); // 请求者去请求命令

        System.out.println("==============分割线===============");

        invoker.setCommand(offCommand); // 给请求者设置 关机命令
        invoker.call(); // 请求者去请求命令

    }
}

class Invoker{ // 请求者
    private Command command; // 命令

    public void setCommand(Command command){ // 设置请求者的命令
        this.command = command;
    }

    public void call(){ // 调用
        command.Execute();
    }
}

interface Command{ // 命令接口
    void Execute(); // 执行命令

}

class OnCommand implements Command{// 开机命令
    private Tv tv;

    public OnCommand(Tv tv){
        this.tv = tv;
    }

    @Override
    public void Execute() {
        tv.OnAction();
    }
}

class OffCommand implements Command{ // 关机命令
    private Tv tv;

    public OffCommand(Tv tv){
        this.tv = tv;
    }

    @Override
    public void Execute() {
        tv.OffAction();
    }
}

class Tv{
    public void OnAction(){ // 开机行为
        System.out.println("电视机开机了...");
    }

    public void OffAction(){ // 关机行为
        System.out.println("电视机关机了...");
    }
}
```

3）适用性

Command 模式适用于：

- 抽象出待执行的动作以参数化某对象。
- 在不同的时刻指定、排列和执行请求。
- 支持取消操作。
- 支持修改日志。
- 用构建在原语操作上的高层操作构造一个系统。

### 3. Interpreter（解释器）

下午没考过，上午考的也少

**如下代码例子，本质就是有多组可以匹配的数组{‘A区’，‘B区’}，{‘开发人员’，‘测试人员’}，如果你需要解释的是A区的开发人员，那么结果就正确，如果是c区的程序员就错误，因为没有c区，你输入的数据比如下面以的进行分割，看看左边和右边分别是否匹配符合要求，都符合要求就返回成功，有一边不匹配就返回失败，例子写的太复杂不看了**

本质上

1）意图

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来
解释语言中的句子。

2）结构

​									<img src="assets/image-20230416093633395.png" style="zoom:67%;" />

```java
/**
 * 解释器模式
 */
public class InterpreterPattern {

    public static void main(String[] args) {

        Context context = new Context();
        //输出结果如下
        context.check("A区的开发人员");
        context.check("B区的调试人员");
        context.check("C区的测试人员");

        System.out.println("========分割线=============");

        context.check("D区的程序员");
        context.check("D区的测试员");
        context.check("C区的程序员");

    }
}

class Context{
    private String[] regions = {"A区","B区","C区"};
    private String[] persions = {"开发人员","测试人员","调试人员"};
    private NonterminalExpression nonterminal;

    public Context(){
        TerminalExpression region = new TerminalExpression(regions);
        TerminalExpression person = new TerminalExpression(persions);
        nonterminal = new NonterminalExpression(region,person);
    }

    public void check(String info){
        boolean result = nonterminal.Interpret(info);
        if (result){
            System.out.println("识别成功~");
        }else {
            System.out.println("识别失败~");
        }
    }

}

interface Expression{
    boolean Interpret(String info);
}

class NonterminalExpression implements Expression{

    private TerminalExpression region;
    private TerminalExpression person;

    public NonterminalExpression(TerminalExpression region,TerminalExpression person){
        this.region =region;
        this.person = person;
    }

    @Override
    public boolean Interpret(String info) {
        String[] str = info.split("的");
        // B区鹅调试人员 --> str = {"B区","调试人员"};
        return region.Interpret(str[0]) && person.Interpret(str[1]);
    }
}

class TerminalExpression implements Expression{

    private Set<String> set = new HashSet<>();

    public TerminalExpression(String[] data){
        for (String str : data) {
            set.add(str);
        }
    }

    @Override
    public boolean Interpret(String info) {
        return set.contains(info);
    }
}
```

输出

![image-20250419104045275](assets/image-20250419104045275.png)

3）适用性

Interpreter模式适用于当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好：

- 该文法简单。对于复杂的发文，文法的类层次变得庞大而无法管理。
- 效率不是一个关键问题。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。

### 4. Iterator（迭代器）

1）意图

提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。

2）结构

​				![](assets/image-20230416103420119.png)

其中：

- Iterator (迭代器)定义访问和遍历元素的接口。
- ConcreteIterator（具体迭代器)实现迭代器接口；对该聚合遍历时跟踪当前位置。
- Aggregate( 聚合)定义创建相应迭代器对象的接口。
- ConcreteAggregate (具体聚合)实现创建相应迭代器的接口，该操作返回 ConcreteIterator的一个适当的实例。

```java
/**
 * 迭代器模式 本质就是实现for循环 需要实现迭代器中是否有下一个元素判断和当发现有下一个元素向后执行的操作
 */
//总体来说就是有一个聚合接口、具体的聚合对象、迭代器、具体的迭代器，具体的聚合对象返回具体的迭代器对象，然后调用具体迭代器对象的方法
public class IteratorPattern {

    public static void main(String[] args) {
        BookAggregate bookAggregate = new BookAggregate();

        String[] books = {"数据结构","操作系统","计算机网络","计算机组成原理"};
        double[] prices = {10.24,20.48,40.96,81.92};

        for (int i = 0; i < 4; i++) {
            bookAggregate.Add(new Book(books[i],prices[i]));
        }
        //JAVA自带的迭代器类，这里是写这个迭代器原码 
        Iterator iterator = bookAggregate.CreateIterator();
        //iterator.hasNext()迭代器自带的 判断是否还有下一个元素，相当于for循环里面判断是否还能继续循环，也是写原码
        while (iterator.hasNext()) {
            //iterator.next()迭代器中取下个元素的方法 (Book)是强制类型转换的意思，强制转换为Book类型
            Book book = (Book) iterator.next();
            System.out.println("书名：" + book.getName() + " 价格：" + book.getPrice());
        }

    }

}
//迭代器
interface Iterator{
    boolean hasNext();
    Object next();
}
//实现具体的迭代器
class BookIterator implements Iterator{
    private int index;
    private BookAggregate bookAggregate;

    public BookIterator(BookAggregate bookAggregate){
        this.index = 0;
        this.bookAggregate = bookAggregate;
    }

    @Override
    public boolean hasNext() {
        if (index < bookAggregate.getSize()){
            return true;
        }
        return false;
    }

    @Override
    public Object next() {
        Object obj = bookAggregate.get(index);
        index ++ ;
        return obj;
    }
}

class BookAggregate implements Aggregate{ 

    private List<Book> list = new ArrayList<>();

    public void Add(Book book){
        list.add(book);
    }

    public Book get(int index){
        return list.get(index);
    }

    public int getSize(){
        return list.size();
    }

    @Override
    public Iterator CreateIterator() {
        //将自身实例化的这个类丢进去
        return new BookIterator(this);
    }
}

interface Aggregate{
    Iterator CreateIterator();
}

class Book{
    private String name;
    private double price;

    public Book(String name,double price){
        this.name = name;
        this.price = price;
    }

    public String getName(){
        return name;
    }

    public double getPrice(){
        return price;
    }
}
```

输出

![image-20250419123938032](assets/image-20250419123938032.png)

3）适用性

Iterator 模式适用于：

- 访问一个聚合对象的内容而无须暴露它的内部表示。
- 支持对聚合对象的多种遍历。
- 为遍历不同的聚合结构提供一个统一的接口。

#### 5. Mediator（中介者）

20年下考过大题

**本质就是如果有多个同事，同事之间的通信不是直接完成，而是由一个媒介，中间人完成，同事a需要和同事b说话，只需要同事a把消息发给中间人，然后中间人发给同事b。之所以这样是因为如果同事多了，那通信会很复杂，把复杂的对象关系用中介者联系起来，易于维护对象的交互关系**

![image-20250419193436937](assets/image-20250419193436937.png)

1）意图

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

2）结构

![image-20250419193918317](assets/image-20250419193918317.png)

其中：

- Mediator (中介者)定义一个接口用于各同事(Colleague)对象通信。
- ConcreteMediator (具体中介者)通过协调各同事对象实现协作行为；了解并维护它的各个同事。
- Colleague class (同事类)知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信。

```java
/**
 * 中介者模式
 */
//调用
public class MediatorPattern {
    public static void main(String[] args) {
        //实例化中介者
        ConcreteMediator mediator = new ConcreteMediator();
        //实例化同事1和同事2
        Colleague1 colleague1 =new Colleague1(mediator);
        Colleague2 colleague2 = new Colleague2(mediator);
       //将同事1和同事2绑定到中介者中
        mediator.setColleague1(colleague1);
        mediator.setColleague2(colleague2);
       //同事1和同事2调用发送消息方法，这个方法里面会将这个消息和实例化的同事1或同事2传入中介者实例的方法
        colleague1.sendMessage("软考加油~");
        colleague2.sendMessage("祝你上岸~");

    }
}

abstract class Colleague{
    protected Mediator mediator;
}

class Colleague1 extends Colleague{
    public Colleague1(Mediator mediator){
        this.mediator = mediator;
    }

    public void sendMessage(String message){
        mediator.sendMessage(message,this);
    }

    public void Notify(String message){
        System.out.println("同事1收到消息：" + message);
    }
}

class Colleague2 extends Colleague{
    public Colleague2(Mediator mediator){
        this.mediator = mediator;
    }

    public void sendMessage(String message){
        //this就是将实例化的自己送进中介者，让中介者知道谁发的消息
        mediator.sendMessage(message,this);
    }

    public void Notify(String message){
        System.out.println("同事2收到消息：" + message);
    }
}

abstract class Mediator{
    public abstract void sendMessage(String message,Colleague colleague);
}

class ConcreteMediator extends Mediator{
    private Colleague1 colleague1;
    private Colleague2 colleague2;

    public void setColleague1(Colleague1 colleague1){
        this.colleague1 = colleague1;
    }

    public void setColleague2(Colleague2 colleague2){
        this.colleague2 = colleague2;
    }

    @Override
    public void sendMessage(String message, Colleague colleague) {
        if (colleague == colleague1){
            // 让同事2收到消息
            colleague2.Notify(message);
        }else {
            // 让同事1收到消息
            colleague1.Notify(message);
        }
    }
}
```

输出

![image-20250419200738523](assets/image-20250419200738523.png)

3）适用性

Mediator 模式适用于：

- 一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。
- 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类。

上午真题1

![image-20250419210514465](assets/image-20250419210514465.png)

#### 6. Memento（备忘录）

**这个模式就是类似与git，记录你操作的那个数据的每一次操作状态，并且可以将状态恢复到之前记录的某次状态，看图，代码是根据这个图写出来的**

1）意图

在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。

2）结构

![](assets/image-20230416150625243.png)

![image-20250419213316129](assets/image-20250419213316129.png)

```java
/**
 * 备忘录模式
 */
public class MementoPattern {
    public static void main(String[] args) {
        //实例化记录者
        Caretaker caretaker = new Caretaker();
        //实例化原发器
        Originator originator = new Originator();
       //初始化状态值
        originator.setState("1024");
        //创造备忘录
        Memento backup1 = originator.createMemento();
        //再记录者中记录备忘录类，每一次记录的都是单独的备忘录类
        caretaker.addMemento(backup1);

        originator.setState("2048");
        Memento backup2 = originator.createMemento();
        caretaker.addMemento(backup2);

        originator.setState("4096");
        Memento backup3 = originator.createMemento();
        caretaker.addMemento(backup3);

        System.out.println(originator.getState());
        caretaker.showMemento();

        Memento memento1 = caretaker.getMemento(2);
        //将记录着回滚到指定的备忘录
        originator.setState(memento1.getState());

        System.out.println("根据第2次备份还原之后的状态为：" + originator.getState());
    }
}

class Originator{ // 原发器
    private String state;

    public void setState(String state){
        this.state = state;
    }

    public String getState(){
        return state;
    }

    public Memento createMemento(){
        return new Memento(state);
    }

    public void setMemento(Memento memento){
        state = memento.getState();
    }
}

class Memento{ // 备忘录
    private String state;

    public String getState(){
        return state;
    }

    public Memento(String state){
        this.state = state;
    }
}

class Caretaker{ // 管理者
    private List<Memento> mementoList = new ArrayList<>();

    public void addMemento(Memento memento){
        mementoList.add(memento);
    }

    public Memento getMemento(int index){
        // 判断参数是否合法
        if (index >=1 && index <= mementoList.size()) {
            return mementoList.get(index - 1);
        }
        return null;
    }

    public void showMemento(){
        int cnt = 1;
        for (Memento memento : mementoList) {
            System.out.println("第" + cnt + "次备份，状态为：" + memento.getState());
            cnt ++;
        }
    }
}
```

输出

![image-20250419212745513](assets/image-20250419212745513.png)

3）适用性

Mement 模式适用于：

- 必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。
- 如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

#### 7. Observer（观察者）（重要！vue2的响应式就是这个原理）

**例子是以b站up主和b站用户来实现的，up主要定义一个粉丝列表，并由添加删除粉丝分方法，当up主的视频更新可以更新状态，需要把这个状态通知粉丝列表里的所有粉丝，当up主的状态发生改变，同步粉丝哪里观察up主的状态也要同步，从subject和observer下面的箭头看出这里一个是两个接口，由具体的两个类继承这两个接口实现功能**

1）意图

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

2）结构

![image-20250419222729744](assets/image-20250419222729744.png)

其中：

-  Subject(目标)知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口。 
-  Observer(观察者)为那些在目标发生改变时需获得通知的对象定义一个更新接口。 
-  ConcreteSubject(具体目标)将有关状态存入各ConcreteObserver对象；当它的状态发生改变时，向它的各个观察者发出通知。 
-  ConcreteObserver (具体观察者)维护一个指向 ConcreteSubject 对象的引用；存储有关状态，这些状态应与目标的状态保持一致
-  实现 Observer 的更新接口，以使自身状态与目标的状态保持一致。 

```java
/**
 * 观察者模式
 */
//输出
public class ObserverPattern {
    public static void main(String[] args) {
        //定义一个up主
        Subject subjectA = new ConcreteSubject("目标A");
        //定义三个具体的用户
        Observer observerB = new ConcreteObserver("张三",subjectA);
        Observer observerC = new ConcreteObserver("李四",subjectA);
        Observer observerD = new ConcreteObserver("王五",subjectA);
        //up主更新状态
        subjectA.setState("更新了");
        System.out.println("---------------------------");
        //删除一个用户
        subjectA.Detach(observerD);
        //删除用户后在打印
        subjectA.setState("停更了");
    }
}

interface Subject { // 目标接口
    void Attach(Observer observer); // 添加观察者

    void Detach(Observer observer); // 删除观察者

    void Notify(); // 状态改变后，通知所有观察者

    void setState(String state); // 设置状态（改变状态）
    String getState(); // 获取状态
}

class ConcreteSubject implements Subject {
    private String name;
    private String state;

    private List<Observer> observerList;

    public ConcreteSubject(String name) {
        state = "未更新";
        this.name = name;
        observerList = new ArrayList<>();
    }

    @Override
    public void Attach(Observer observer) {
        observerList.add(observer);
    }

    @Override
    public void Detach(Observer observer) {
        observerList.remove(observer);
    }

    @Override
    public void Notify() {
        for (Observer observer : observerList) {
            observer.update();
        }
    }

    @Override
    public void setState(String state) {
        this.state = state;

        System.out.println(name + "的状态发生变化，变化后的状态为：" + state);
        Notify();
    }

    @Override
    public String getState() {
        return state;
    }
}

interface Observer { // 观察者接口
    void update();  // 收到通知，更新观察者的状态
}

class ConcreteObserver implements Observer {

    private String name;
    private String state;

    private Subject subject;

    public ConcreteObserver(String name, Subject subject) {
        this.name = name;
        this.subject = subject;
        subject.Attach(this);
        state = subject.getState();
    }

    @Override
    public void update() {
        System.out.println(name + " 收到通知");
        state = subject.getState(); //  让当前观察者的状态 和 目标改变后的状态保持一致
        System.out.println(name + " 改变后的状态为："+state);
    }
}
```

输出结果

![image-20250419223158137](assets/image-20250419223158137.png)

3）适用性

Observer 模式适用于：

- 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。
- 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。
- 当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。

上午真题1

![image-20250420141304027](assets/image-20250420141304027.png)

真题2

![image-20250420142518391](assets/image-20250420142518391.png)

真题3

![image-20250420142822429](assets/image-20250420142822429.png)

真题4

![image-20250420142848194](assets/image-20250420142848194.png)





注意点

如果存在一个父类接口，一个子类继承了父类，在别的类中new了这个父类，是无法使用子类中定义的不属于父类的方法或属性的，解决办法，在父类中把这个别的类想使用的属性或方法也定义一份，那么子类就属于继承并覆盖，

#### 8. State（状态）

**可以用贩卖机的例子来说明，context就是贩卖机，里面有货的数量，而state的两个子类就是有货和无货这两种状态，看下面代码实现即可**

1）意图

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

2）结构

![image-20250420145053836](assets/image-20250420145053836.png)

![image-20250420150233310](assets/image-20250420150233310.png)

```java
/**
 * 状态模式
 */

public class StatePattern {
    public static void main(String[] args) {
        Context context = new Context(); // count = 3

        System.out.println("状态：" + context.getState() + " 数量：" + context.getCount());

        context.Request(); // 购买一个饮料 count = 2
        context.Request(); // 购买一个饮料 count = 1
        context.Request(); // 购买一个饮料 count = 0

        System.out.println("状态：" + context.getState() + " 数量：" + context.getCount());

        context.Request(); // 无货，等待补货

        System.out.println("状态：" + context.getState() + " 数量：" + context.getCount());

        context.Request(); // 购买一个饮料 count = 4
        System.out.println("状态：" + context.getState() + " 数量：" + context.getCount());

    }
}

class Context{ // 贩卖机
    private int count;

    private State state;

    public Context(){
        count = 3;
        state = new StateA();//初始状态为有货
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }

    public void Request(){  // 购买饮料
        state.Handle(this);
    }
}

interface State{
    void Handle(Context context);
}

class StateA implements State{

    @Override
    public void Handle(Context context) {
        int count = context.getCount();

        if (count >= 1){
            System.out.println("购买成功~");
            context.setCount(count - 1);

            if (context.getCount() == 0){
                context.setState(new StateB()); // 设置为无货状态
            }
        }else {
            System.out.println("购买失败~");
        }
    }
}

class StateB implements State{

    @Override
    public void Handle(Context context) {
        int count = context.getCount();

        if (count == 0){
            System.out.println("购买失败！等待补货~");

            context.setCount(5);
            System.out.println("补货成功，请重新购买~");

            context.setState(new StateA());
        }
    }
}
```

输出

![image-20250420144707436](assets/image-20250420144707436.png)

3）适用性

State 模式适用于：

- 一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。
- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。

上午真题1

![image-20250420145945427](assets/image-20250420145945427.png)

真题2 

![image-20250420150541803](assets/image-20250420150541803.png)

#### 9. Strategy（策略）（下午题考过多次）

**这个模式就是比如策略里面有加减乘除四种方法，我们实例化context类，就可以往这个类里面穿加减乘除四种类其中一种去执行不同的操作**

1）意图

定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。

2）结构

![](assets/image-20230417110447963.png)

![image-20250420152128997](assets/image-20250420152128997.png)

```java
/**
 * 策略模式
 */
public class StrategyPattern {
    public static void main(String[] args) {

        OperationContext context = new OperationContext(new Addstrategy());
        context.Operation(20,17);

        context = new OperationContext(new Substrategy());
        context.Operation(20,17);

        context = new OperationContext(new Multstrategy());
        context.Operation(20,17);
    }
}

class OperationContext{
    private Strategy strategy;

    public OperationContext(Strategy strategy){
        this.strategy =strategy;
    }

    public void Operation(int a, int b){
        strategy.TwoNumberOperation(a,b);
    }
}


interface Strategy{
    void TwoNumberOperation(int a,int b);
}

class Addstrategy implements Strategy{

    @Override
    public void TwoNumberOperation(int a, int b) {
        System.out.println(a + b);
    }
}

class Substrategy implements Strategy{

    @Override
    public void TwoNumberOperation(int a, int b) {
        System.out.println(a - b);
    }
}

class Multstrategy implements Strategy{

    @Override
    public void TwoNumberOperation(int a, int b) {
        System.out.println(a * b);
    }
}
```

输出

![image-20250420152356600](assets/image-20250420152356600.png)

3）适用性

Strategy 模式适用于：

-  许多相关的类仅仅是行为有异。 
-  需要使用一个算法的不同变体。 
-  算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。 
-  一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的 Strategy 类中，以代替这些条 件语句。 

上午真题1

![image-20250420152418261](assets/image-20250420152418261.png)

真题2

![image-20250420152432712](assets/image-20250420152432712.png)

真题3

![image-20250420152531241](assets/image-20250420152531241.png)

#### 10. Template Method（模板方法）

**本质就是避免代码重复，把服用的代码抽离到公共类，然后不能复用的类似方法在不同类做不同操作，注意肯定是类似方法，比如学生和老师，很简单下午题应该不会考**

1）意图

定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

2）结构

![](assets/image-20230417112937358.png)

其中：

- AbstractClass（抽象类）定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤；实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作。
- ConcreteClass（具体类）实现原语操作以完成算法中与特定子类相关的步骤。

```java
/**
 * 模板方法模式
 */
public class TemplateMethodPattern {
    public static void main(String[] args) {
        // 父类名 对象名 = new 子类名();

        Person student = new Student();
        Person teacher = new Teacher();

        student.TemplateMethod();

        System.out.println("=========分割线=============");

        teacher.TemplateMethod();
    }
}

abstract class Person{
    public void TemplateMethod(){
        System.out.println("上课 去教室");
        PrimitiveOperation1();
        System.out.println("下课 离开教室");
        PrimitiveOperation2();
    }

    public abstract void PrimitiveOperation1(); // 原语操作 1：上课过程 学生 听课... 老师 讲课
    public abstract void PrimitiveOperation2(); // 原语操作 2：作业  学生 写作业 提交作业... 老师批改作业 打分数
}

class Student extends Person{

    @Override
    public void PrimitiveOperation1() {
        System.out.println("学生：听课 学习 做笔记 提出问题");
    }

    @Override
    public void PrimitiveOperation2() {
        System.out.println("学生：写作业 提交作业");
    }
}

class Teacher extends Person{

    @Override
    public void PrimitiveOperation1() {
        System.out.println("老师：上课 讲课 解答问题 布置作业");
    }

    @Override
    public void PrimitiveOperation2() {
        System.out.println("老师：批改作业 打分数");
    }
}
```

输出

![image-20250420154215540](assets/image-20250420154215540.png)

3）适用性

Template Method 模式适用于：

-  一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 
-  各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复。 
-  控制子类扩展：模板方法在特定点调用“hook”操作(默认行为，子类可以在必要时进行重定义扩展)，这就只允许在这些点进行扩展。

#### 11. Visitor（访问者）

访问者模式其实我也不是特别理解什么时候应该用，但是下面代码是看懂了的，核心还是这个图

1）意图

表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。

2）结构

​											<img src="assets/image-20230417135729720.png" style="zoom: 50%;" />

其中：

-  Visitor(访问者)为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。该操作的名字和特征标识了发送 Vist 请求给该访问者的那个类，这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。 
-  ConcreteVisitor (具体访问者)实现每个有 Visitor 声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。Concrete Visitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。 
-  **Element (元素)定义以一个访问者为参数的 Accept 操作**。 
-  ConcreteElement (具体元素)实现以一个访问者为参数的 Accept 操作。 
-  ObjectStructure (对象结构)能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合，如一个列表或一个无序集合。 

```java
/**
 * 访问者模式
 */
public class VisitorPattern {
    public static void main(String[] args) {
        PersonStructure structure = new PersonStructure();

        Visitor1 visitor1 = new Visitor1();
        System.out.println("访问者1的访问记录：");
        structure.Accept(visitor1);
        System.out.println("学生年龄的总和：" + visitor1.getStudentAgeSum() +" 老师年龄的总和：" + visitor1.getTeacherAgeSUm());

        System.out.println("=========分割线==============");

        Visitor2 visitor2 = new Visitor2();
        System.out.println("访问者2的访问记录：");
        structure.Accept(visitor2);
        System.out.println("学生的最高成绩：" + visitor2.getMaxScore() + " 老师的最高工龄：" + visitor2.getMaxWorkYear());

    }
}

interface Visitor{
    void VistStudent(Student student); // 访问
    void vistTeacher(Teacher teacher); // 访问老师
}

class Visitor1 implements Visitor{ // 访问者1 分别统计学生和老师的年龄总和
    private int studentAgeSum = 0;
    private int teacherAgeSUm =0;

    public int getStudentAgeSum() {
        return studentAgeSum;
    }

    public int getTeacherAgeSUm() {
        return teacherAgeSUm;
    }

    @Override
    public void VistStudent(Student student) {
        System.out.println("访问者1访问学生：" + student.getName() + " 年龄：" + student.getAge());
        studentAgeSum += student.getAge();
    }

    @Override
    public void vistTeacher(Teacher teacher) {
        System.out.println("访问者1访问老师：" + teacher.getName() + " 年龄：" + teacher.getAge());
        teacherAgeSUm += teacher.getAge();
    }
}

class Visitor2 implements Visitor{ // 访问者2 分别求出 学生的最高成绩 以及 老师的最高工龄
    private int maxScore = -1;
    private int maxWorkYear = -1;

    public int getMaxScore() {
        return maxScore;
    }

    public int getMaxWorkYear() {
        return maxWorkYear;
    }

    @Override
    public void VistStudent(Student student) {
        System.out.println("访问者2访问学生：" + student.getName() + " 成绩：" + student.getScore());
        maxScore = Math.max(maxScore,student.getScore());
    }

    @Override
    public void vistTeacher(Teacher teacher) {
        System.out.println("访问者2访问老师：" + teacher.getName() + " 工龄：" + teacher.getWorkYear());
        maxWorkYear = Math.max(maxWorkYear,teacher.getWorkYear());
    }
}

class PersonStructure{
    private List<Person> personList = new ArrayList<>();

    public PersonStructure(){
        personList.add(new Student("张三",20,70));
        personList.add(new Student("李四",21,80));
        personList.add(new Student("王五",22,90));

        personList.add(new Teacher("李老师",26,3));
        personList.add(new Teacher("陈老师",27,4));
        personList.add(new Teacher("刘老师",28,5));
    }

    public void Accept(Visitor visitor){
        for (Person person : personList) {
            person.Accept(visitor);
        }
    }
}

abstract class Person{
    private String name;
    private int age;


    public Person(String  name,int age){
        this.name = name;
        this.age = age;
    }

    public String getName(){
        return name;
    }

    public int getAge() {
        return age;
    }

    public abstract void Accept(Visitor visitor);
}

class Student extends Person{

    private int score;
    public Student(String name,int age,int score){
        super(name,age);
        this.score = score;
    }

    public int getScore(){
        return score;
    }

    @Override
    public void Accept(Visitor visitor) {
        visitor.VistStudent(this);
    }
}

class Teacher extends Person{
    private int workYear;
    public Teacher(String name,int age,int workYear){
        super(name,age);
        this.workYear = workYear;
    }

    public int getWorkYear(){
        return workYear;
    }

    @Override
    public void Accept(Visitor visitor) {
        visitor.vistTeacher(this);
    }
}
```

输出

![image-20250420163242118](assets/image-20250420163242118.png)

3）适用性

Visitor 模式适用于：

- 一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。

- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作“污染”这些对象的类。

- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。

  

上午真题1

![image-20250420164140173](assets/image-20250420164140173.png)

真题2

![image-20250420164753798](assets/image-20250420164753798.png)



### 总结

**抽象工厂（方法）生成原型单例，桥代理组合适配器，享元回家装饰外观**















## 下午代码题注意

1.如下父抽象类中的私有变量在子类使用时候需要注意的点

![image-20250420163717416](assets/image-20250420163717416.png)

2.抽象类不一定由抽象方法，有抽象方法一定是抽象类



#### 真题

抽象工厂模式

![image-20250420175357578](assets/image-20250420175357578.png)



## 下午题3

考的最多的是类图+用例图，状态图和活动图也可能会考，构建和部署图这种物理图没考过，对象图也没考过，序列图也没考过

![image-20250409164009146](assets/image-20250409164009146.png)

![image-20250409192120305](assets/image-20250409192120305.png)

用例图中包含和泛化的区别

a包含b，那么a一定要具有b，才能实现功能，没有b，a就无法实现；而b不需要a就可以实现自己的功能；

a泛化b，那么b包含a的所有属性和方法，且可以添加新的属性和方法，**利用b也可实现a，也就是子用例可以替代父用例，总之就是想要实现比如支付，支付自身可以实现，用微信支付也可以实现，不需要父，子就可以实现父的功能**

扩展

![image-20250410104835085](assets/image-20250410104835085.png)

**区别**

泛化中，b包含a的所有属性和方法；而包含关系中b不会继承a的任何属性或方法

**举例**

1.从武汉去东莞

选择坐飞机去东莞，选择坐高铁去东莞，这两种方式都可以到达，可以说这两种方式时从武汉去东莞这个类的特殊行为，所以这是泛化，而不是包含。

2.支付

微信支付和支付宝支付都属于支付的方式，所以这是泛化；而支付需要验证用户身份，比如输入密码，输入指纹，单独的输入密码或者输入指纹都不能达到支付的作用，而支付必须依赖这些方式，所以这是包含，而不是泛化。

3.

![image-20250410103959306](assets/image-20250410103959306.png)

如何选择

![image-20250410104850828](assets/image-20250410104850828.png)

答题技巧，问类图的类名时，可以看题干中的英文，都是类名，如果都是中文，**要注意类名全都是名词，而不是动词，用例都是动词**，类图中无向边是关联，单项实线加>这种箭头是单项关联，在关联多重度中可以看到相关示例。虚线箭头是依赖，实线箭头是关联，实线无箭头也就是无向边就是双向关联。用例图的椭圆里面是用例，

**2021下**

![image-20250410144641622](assets/image-20250410144641622.png)

![image-20250410151719313](assets/image-20250410151719313.png)

![image-20250410151039571](assets/image-20250410151039571.png)

问题1解析

用例图上用户的两个用例，第一个建立迷宫，可以找到题干，建立迷宫可以通过编写迷宫文件和导入迷宫文件两种方式，所以U1和U2分别是这两个；再看操作机器人用例，题干写到每个机器人都要设置一个定时器，所以U3是设置定时器

问题2解析

编写迷宫文件和导入迷宫文件都属于建立迷宫，是特殊的子类，所以是泛化关系；而设置计时器是操作机器人的必须方式，不设置定时器就无法操作机器人，所以是include包含关系

问题3解析

找类名的时候我们可以注意题干中的英文，这些都是类名，然后看类图中有两个二对1的泛化关系，从题干可以找到机器人包含小精灵和幽灵；机器人有两种传感器包含前向传感器和近距离传感器这两个二对一的泛化关系，且由于机器人包含传感器，传感器有泛化的子级，综合可以判断出C1,C3,C4,C5,C6,C7,其他就很好推断出来了



**2021上**

![image-20250410175457283](assets/image-20250410175457283.png)

![image-20250410181230778](assets/image-20250410181230778.png)



问题1

这题的关键是U2到底是支付方式还是取药方式，因为这两个都是1对2的泛化，U2是支付方式，我们从关键性来考虑，只有支付成功了才能取药，而取药方式并不是那么重要的，且取药方式中有送药上门，送药上门不是患者的功能，而是快递人员的功能；且题干说明了支付成功处方才会发送给药师配置药品，所以是支付方式。

**问题2(这一问很难)**

我们从名词去考虑，c1这里有一个泛化和一个组合，对于患者有两个泛化，一个是支付方式，一个是取药方式，按照问题1的理解支付方式和取药方式中，支付方式才是能决定患者的因素，而取消方式不是决定性因素，所以是支付方式，**不能凭借感觉选，我的感觉是取消方式，是错的**，再看组合，就是找c1是患者的一部分，这里从上面用例图看，患者单向关联支付方式。（这个c1其实很牵强，只能尽量做对），而c4可以通过支付成功后厨房发送给药师配置药品看出是处方，而处方单项关联药品（还是有点牵强，感觉应该是药品单项关联处方）

2020年下

![image-20250410215830053](assets/image-20250410215830053.png)

![image-20250410215801905](assets/image-20250410215801905.png)

问题1

U1答错了，应该是审批授权，好好理解一下题干；U3也好好理解，这个是合理的，U3要结合和归档的关系看，**这里我自己写成了售出和停售的房产信息，但是这明显是一个名词，用例都是动词，所以就应该去考虑别的，而删除房产可以被理解为归档的延申，所以U3是删除房产，b是extend**

